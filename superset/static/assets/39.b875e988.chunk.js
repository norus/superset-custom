(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[39],{

/***/ "./node_modules/@superset-ui/legacy-plugin-chart-parallel-coordinates/esm/ParallelCoordinates.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/@superset-ui/legacy-plugin-chart-parallel-coordinates/esm/ParallelCoordinates.js ***!
  \*******************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3 */ \"./node_modules/d3/d3.js\");\n/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(d3__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prop-types */ \"./node_modules/prop-types/index.js\");\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _superset_ui_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @superset-ui/core */ \"./node_modules/@superset-ui/core/esm/color/SequentialSchemeRegistrySingleton.js\");\n/* harmony import */ var _vendor_parcoords_d3_parcoords__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./vendor/parcoords/d3.parcoords */ \"./node_modules/@superset-ui/legacy-plugin-chart-parallel-coordinates/esm/vendor/parcoords/d3.parcoords.js\");\n/* harmony import */ var _vendor_parcoords_divgrid__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./vendor/parcoords/divgrid */ \"./node_modules/@superset-ui/legacy-plugin-chart-parallel-coordinates/esm/vendor/parcoords/divgrid.js\");\n/* harmony import */ var _vendor_parcoords_d3_parcoords_css__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./vendor/parcoords/d3.parcoords.css */ \"./node_modules/@superset-ui/legacy-plugin-chart-parallel-coordinates/esm/vendor/parcoords/d3.parcoords.css\");\n/* harmony import */ var _vendor_parcoords_d3_parcoords_css__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_vendor_parcoords_d3_parcoords_css__WEBPACK_IMPORTED_MODULE_5__);\n/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n/* eslint-disable react/sort-prop-types */\n\n\n\n\n\n\nconst propTypes = {\n  // Standard tabular data [{ fieldName1: value1, fieldName2: value2 }]\n  data: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.arrayOf(prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.object),\n  width: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.number,\n  height: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.number,\n  colorMetric: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,\n  includeSeries: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.bool,\n  linearColorScheme: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,\n  metrics: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.arrayOf(prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string),\n  series: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,\n  showDatatable: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.bool\n};\n\nfunction ParallelCoordinates(element, props) {\n  const {\n    data,\n    width,\n    height,\n    colorMetric,\n    includeSeries,\n    linearColorScheme,\n    metrics,\n    series,\n    showDatatable\n  } = props;\n  const cols = includeSeries ? [series].concat(metrics) : metrics;\n  const ttypes = {};\n  ttypes[series] = 'string';\n  metrics.forEach(v => {\n    ttypes[v] = 'number';\n  });\n  const colorScale = colorMetric ? Object(_superset_ui_core__WEBPACK_IMPORTED_MODULE_2__[\"default\"])().get(linearColorScheme).createLinearScale(d3__WEBPACK_IMPORTED_MODULE_0___default.a.extent(data, d => d[colorMetric])) : () => 'grey';\n\n  const color = d => colorScale(d[colorMetric]);\n\n  const container = d3__WEBPACK_IMPORTED_MODULE_0___default.a.select(element).classed('superset-legacy-chart-parallel-coordinates', true);\n  container.selectAll('*').remove();\n  const effHeight = showDatatable ? height / 2 : height;\n  const div = container.append('div').style('height', effHeight + \"px\").classed('parcoords', true);\n  const chart = Object(_vendor_parcoords_d3_parcoords__WEBPACK_IMPORTED_MODULE_3__[\"default\"])()(div.node()).width(width).color(color).alpha(0.5).composite('darken').height(effHeight).data(data).dimensions(cols).types(ttypes).render().createAxes().shadows().reorderable().brushMode('1D-axes');\n\n  if (showDatatable) {\n    // create data table, row hover highlighting\n    const grid = Object(_vendor_parcoords_divgrid__WEBPACK_IMPORTED_MODULE_4__[\"default\"])();\n    container.append('div').style('height', effHeight + \"px\").datum(data).call(grid).classed('parcoords grid', true).selectAll('.row').on({\n      mouseover(d) {\n        chart.highlight([d]);\n      },\n\n      mouseout: chart.unhighlight\n    }); // update data table on brush event\n\n    chart.on('brush', d => {\n      d3__WEBPACK_IMPORTED_MODULE_0___default.a.select('.grid').datum(d).call(grid).selectAll('.row').on({\n        mouseover(dd) {\n          chart.highlight([dd]);\n        },\n\n        mouseout: chart.unhighlight\n      });\n    });\n  }\n}\n\nParallelCoordinates.displayName = 'ParallelCoordinates';\nParallelCoordinates.propTypes = propTypes;\n/* harmony default export */ __webpack_exports__[\"default\"] = (ParallelCoordinates);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHN1cGVyc2V0LXVpL2xlZ2FjeS1wbHVnaW4tY2hhcnQtcGFyYWxsZWwtY29vcmRpbmF0ZXMvZXNtL1BhcmFsbGVsQ29vcmRpbmF0ZXMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHN1cGVyc2V0LXVpL2xlZ2FjeS1wbHVnaW4tY2hhcnQtcGFyYWxsZWwtY29vcmRpbmF0ZXMvZXNtL1BhcmFsbGVsQ29vcmRpbmF0ZXMuanM/ZDA0YyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiAqIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuICogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiAqIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiAqIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiAqIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuICogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qIGVzbGludC1kaXNhYmxlIHJlYWN0L3NvcnQtcHJvcC10eXBlcyAqL1xuaW1wb3J0IGQzIGZyb20gJ2QzJztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgeyBnZXRTZXF1ZW50aWFsU2NoZW1lUmVnaXN0cnkgfSBmcm9tICdAc3VwZXJzZXQtdWkvY29yZSc7XG5pbXBvcnQgcGFyY29vcmRzIGZyb20gJy4vdmVuZG9yL3BhcmNvb3Jkcy9kMy5wYXJjb29yZHMnO1xuaW1wb3J0IGRpdmdyaWQgZnJvbSAnLi92ZW5kb3IvcGFyY29vcmRzL2RpdmdyaWQnO1xuaW1wb3J0ICcuL3ZlbmRvci9wYXJjb29yZHMvZDMucGFyY29vcmRzLmNzcyc7XG5jb25zdCBwcm9wVHlwZXMgPSB7XG4gIC8vIFN0YW5kYXJkIHRhYnVsYXIgZGF0YSBbeyBmaWVsZE5hbWUxOiB2YWx1ZTEsIGZpZWxkTmFtZTI6IHZhbHVlMiB9XVxuICBkYXRhOiBQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMub2JqZWN0KSxcbiAgd2lkdGg6IFByb3BUeXBlcy5udW1iZXIsXG4gIGhlaWdodDogUHJvcFR5cGVzLm51bWJlcixcbiAgY29sb3JNZXRyaWM6IFByb3BUeXBlcy5zdHJpbmcsXG4gIGluY2x1ZGVTZXJpZXM6IFByb3BUeXBlcy5ib29sLFxuICBsaW5lYXJDb2xvclNjaGVtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgbWV0cmljczogUHJvcFR5cGVzLmFycmF5T2YoUHJvcFR5cGVzLnN0cmluZyksXG4gIHNlcmllczogUHJvcFR5cGVzLnN0cmluZyxcbiAgc2hvd0RhdGF0YWJsZTogUHJvcFR5cGVzLmJvb2xcbn07XG5cbmZ1bmN0aW9uIFBhcmFsbGVsQ29vcmRpbmF0ZXMoZWxlbWVudCwgcHJvcHMpIHtcbiAgY29uc3Qge1xuICAgIGRhdGEsXG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIGNvbG9yTWV0cmljLFxuICAgIGluY2x1ZGVTZXJpZXMsXG4gICAgbGluZWFyQ29sb3JTY2hlbWUsXG4gICAgbWV0cmljcyxcbiAgICBzZXJpZXMsXG4gICAgc2hvd0RhdGF0YWJsZVxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IGNvbHMgPSBpbmNsdWRlU2VyaWVzID8gW3Nlcmllc10uY29uY2F0KG1ldHJpY3MpIDogbWV0cmljcztcbiAgY29uc3QgdHR5cGVzID0ge307XG4gIHR0eXBlc1tzZXJpZXNdID0gJ3N0cmluZyc7XG4gIG1ldHJpY3MuZm9yRWFjaCh2ID0+IHtcbiAgICB0dHlwZXNbdl0gPSAnbnVtYmVyJztcbiAgfSk7XG4gIGNvbnN0IGNvbG9yU2NhbGUgPSBjb2xvck1ldHJpYyA/IGdldFNlcXVlbnRpYWxTY2hlbWVSZWdpc3RyeSgpLmdldChsaW5lYXJDb2xvclNjaGVtZSkuY3JlYXRlTGluZWFyU2NhbGUoZDMuZXh0ZW50KGRhdGEsIGQgPT4gZFtjb2xvck1ldHJpY10pKSA6ICgpID0+ICdncmV5JztcblxuICBjb25zdCBjb2xvciA9IGQgPT4gY29sb3JTY2FsZShkW2NvbG9yTWV0cmljXSk7XG5cbiAgY29uc3QgY29udGFpbmVyID0gZDMuc2VsZWN0KGVsZW1lbnQpLmNsYXNzZWQoJ3N1cGVyc2V0LWxlZ2FjeS1jaGFydC1wYXJhbGxlbC1jb29yZGluYXRlcycsIHRydWUpO1xuICBjb250YWluZXIuc2VsZWN0QWxsKCcqJykucmVtb3ZlKCk7XG4gIGNvbnN0IGVmZkhlaWdodCA9IHNob3dEYXRhdGFibGUgPyBoZWlnaHQgLyAyIDogaGVpZ2h0O1xuICBjb25zdCBkaXYgPSBjb250YWluZXIuYXBwZW5kKCdkaXYnKS5zdHlsZSgnaGVpZ2h0JywgZWZmSGVpZ2h0ICsgXCJweFwiKS5jbGFzc2VkKCdwYXJjb29yZHMnLCB0cnVlKTtcbiAgY29uc3QgY2hhcnQgPSBwYXJjb29yZHMoKShkaXYubm9kZSgpKS53aWR0aCh3aWR0aCkuY29sb3IoY29sb3IpLmFscGhhKDAuNSkuY29tcG9zaXRlKCdkYXJrZW4nKS5oZWlnaHQoZWZmSGVpZ2h0KS5kYXRhKGRhdGEpLmRpbWVuc2lvbnMoY29scykudHlwZXModHR5cGVzKS5yZW5kZXIoKS5jcmVhdGVBeGVzKCkuc2hhZG93cygpLnJlb3JkZXJhYmxlKCkuYnJ1c2hNb2RlKCcxRC1heGVzJyk7XG5cbiAgaWYgKHNob3dEYXRhdGFibGUpIHtcbiAgICAvLyBjcmVhdGUgZGF0YSB0YWJsZSwgcm93IGhvdmVyIGhpZ2hsaWdodGluZ1xuICAgIGNvbnN0IGdyaWQgPSBkaXZncmlkKCk7XG4gICAgY29udGFpbmVyLmFwcGVuZCgnZGl2Jykuc3R5bGUoJ2hlaWdodCcsIGVmZkhlaWdodCArIFwicHhcIikuZGF0dW0oZGF0YSkuY2FsbChncmlkKS5jbGFzc2VkKCdwYXJjb29yZHMgZ3JpZCcsIHRydWUpLnNlbGVjdEFsbCgnLnJvdycpLm9uKHtcbiAgICAgIG1vdXNlb3ZlcihkKSB7XG4gICAgICAgIGNoYXJ0LmhpZ2hsaWdodChbZF0pO1xuICAgICAgfSxcblxuICAgICAgbW91c2VvdXQ6IGNoYXJ0LnVuaGlnaGxpZ2h0XG4gICAgfSk7IC8vIHVwZGF0ZSBkYXRhIHRhYmxlIG9uIGJydXNoIGV2ZW50XG5cbiAgICBjaGFydC5vbignYnJ1c2gnLCBkID0+IHtcbiAgICAgIGQzLnNlbGVjdCgnLmdyaWQnKS5kYXR1bShkKS5jYWxsKGdyaWQpLnNlbGVjdEFsbCgnLnJvdycpLm9uKHtcbiAgICAgICAgbW91c2VvdmVyKGRkKSB7XG4gICAgICAgICAgY2hhcnQuaGlnaGxpZ2h0KFtkZF0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIG1vdXNlb3V0OiBjaGFydC51bmhpZ2hsaWdodFxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn1cblxuUGFyYWxsZWxDb29yZGluYXRlcy5kaXNwbGF5TmFtZSA9ICdQYXJhbGxlbENvb3JkaW5hdGVzJztcblBhcmFsbGVsQ29vcmRpbmF0ZXMucHJvcFR5cGVzID0gcHJvcFR5cGVzO1xuZXhwb3J0IGRlZmF1bHQgUGFyYWxsZWxDb29yZGluYXRlczsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@superset-ui/legacy-plugin-chart-parallel-coordinates/esm/ParallelCoordinates.js\n");

/***/ }),

/***/ "./node_modules/@superset-ui/legacy-plugin-chart-parallel-coordinates/esm/ReactParallelCoordinates.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/@superset-ui/legacy-plugin-chart-parallel-coordinates/esm/ReactParallelCoordinates.js ***!
  \************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _superset_ui_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @superset-ui/core */ \"./node_modules/@superset-ui/core/esm/chart/components/reactify.js\");\n/* harmony import */ var _superset_ui_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @superset-ui/core */ \"./node_modules/@superset-ui/core/esm/style/index.js\");\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! prop-types */ \"./node_modules/prop-types/index.js\");\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _ParallelCoordinates__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ParallelCoordinates */ \"./node_modules/@superset-ui/legacy-plugin-chart-parallel-coordinates/esm/ParallelCoordinates.js\");\nfunction _templateObject() {\n  const data = _taggedTemplateLiteralLoose([\"\\n  .superset-legacy-chart-parallel-coordinates {\\n    div.grid {\\n      overflow: auto;\\n      div.row {\\n        &:hover {\\n          background-color: #ccc;\\n        }\\n      }\\n    }\\n  }\\n\"]);\n\n  _templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _taggedTemplateLiteralLoose(strings, raw) { if (!raw) { raw = strings.slice(0); } strings.raw = raw; return strings; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n\n\n\nconst ReactComponent = Object(_superset_ui_core__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(_ParallelCoordinates__WEBPACK_IMPORTED_MODULE_4__[\"default\"]);\n\nconst ParallelCoordianes = (_ref) => {\n  let {\n    className\n  } = _ref,\n      otherProps = _objectWithoutPropertiesLoose(_ref, [\"className\"]);\n\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\"div\", {\n    className: className\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(ReactComponent, otherProps));\n};\n\nParallelCoordianes.propTypes = {\n  className: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.string.isRequired\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (Object(_superset_ui_core__WEBPACK_IMPORTED_MODULE_2__[\"styled\"])(ParallelCoordianes)(_templateObject()));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHN1cGVyc2V0LXVpL2xlZ2FjeS1wbHVnaW4tY2hhcnQtcGFyYWxsZWwtY29vcmRpbmF0ZXMvZXNtL1JlYWN0UGFyYWxsZWxDb29yZGluYXRlcy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ac3VwZXJzZXQtdWkvbGVnYWN5LXBsdWdpbi1jaGFydC1wYXJhbGxlbC1jb29yZGluYXRlcy9lc20vUmVhY3RQYXJhbGxlbENvb3JkaW5hdGVzLmpzPzZkNWUiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gX3RlbXBsYXRlT2JqZWN0KCkge1xuICBjb25zdCBkYXRhID0gX3RhZ2dlZFRlbXBsYXRlTGl0ZXJhbExvb3NlKFtcIlxcbiAgLnN1cGVyc2V0LWxlZ2FjeS1jaGFydC1wYXJhbGxlbC1jb29yZGluYXRlcyB7XFxuICAgIGRpdi5ncmlkIHtcXG4gICAgICBvdmVyZmxvdzogYXV0bztcXG4gICAgICBkaXYucm93IHtcXG4gICAgICAgICY6aG92ZXIge1xcbiAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjY2NjO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfVxcbiAgfVxcblwiXSk7XG5cbiAgX3RlbXBsYXRlT2JqZWN0ID0gZnVuY3Rpb24gX3RlbXBsYXRlT2JqZWN0KCkge1xuICAgIHJldHVybiBkYXRhO1xuICB9O1xuXG4gIHJldHVybiBkYXRhO1xufVxuXG5mdW5jdGlvbiBfdGFnZ2VkVGVtcGxhdGVMaXRlcmFsTG9vc2Uoc3RyaW5ncywgcmF3KSB7IGlmICghcmF3KSB7IHJhdyA9IHN0cmluZ3Muc2xpY2UoMCk7IH0gc3RyaW5ncy5yYXcgPSByYXc7IHJldHVybiBzdHJpbmdzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSB7fTsgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpOyB2YXIga2V5LCBpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuLyoqXG4gKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4gKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiAqIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4gKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4gKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4gKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcbiAqIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4gKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4gKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4gKiB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHN0eWxlZCwgcmVhY3RpZnkgfSBmcm9tICdAc3VwZXJzZXQtdWkvY29yZSc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IENvbXBvbmVudCBmcm9tICcuL1BhcmFsbGVsQ29vcmRpbmF0ZXMnO1xuY29uc3QgUmVhY3RDb21wb25lbnQgPSByZWFjdGlmeShDb21wb25lbnQpO1xuXG5jb25zdCBQYXJhbGxlbENvb3JkaWFuZXMgPSAoX3JlZikgPT4ge1xuICBsZXQge1xuICAgIGNsYXNzTmFtZVxuICB9ID0gX3JlZixcbiAgICAgIG90aGVyUHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfcmVmLCBbXCJjbGFzc05hbWVcIl0pO1xuXG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgY2xhc3NOYW1lOiBjbGFzc05hbWVcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3RDb21wb25lbnQsIG90aGVyUHJvcHMpKTtcbn07XG5cblBhcmFsbGVsQ29vcmRpYW5lcy5wcm9wVHlwZXMgPSB7XG4gIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkXG59O1xuZXhwb3J0IGRlZmF1bHQgc3R5bGVkKFBhcmFsbGVsQ29vcmRpYW5lcykoX3RlbXBsYXRlT2JqZWN0KCkpOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@superset-ui/legacy-plugin-chart-parallel-coordinates/esm/ReactParallelCoordinates.js\n");

/***/ }),

/***/ "./node_modules/@superset-ui/legacy-plugin-chart-parallel-coordinates/esm/vendor/parcoords/d3.parcoords.css":
/*!******************************************************************************************************************!*\
  !*** ./node_modules/@superset-ui/legacy-plugin-chart-parallel-coordinates/esm/vendor/parcoords/d3.parcoords.css ***!
  \******************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var content = __webpack_require__(/*! !../../../../../css-loader??ref--7-1!./d3.parcoords.css */ \"./node_modules/css-loader/index.js?!./node_modules/@superset-ui/legacy-plugin-chart-parallel-coordinates/esm/vendor/parcoords/d3.parcoords.css\");\n\nif (typeof content === 'string') {\n  content = [[module.i, content, '']];\n}\n\nvar options = {}\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = __webpack_require__(/*! ../../../../../style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\")(content, options);\n\nif (content.locals) {\n  module.exports = content.locals;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHN1cGVyc2V0LXVpL2xlZ2FjeS1wbHVnaW4tY2hhcnQtcGFyYWxsZWwtY29vcmRpbmF0ZXMvZXNtL3ZlbmRvci9wYXJjb29yZHMvZDMucGFyY29vcmRzLmNzcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ac3VwZXJzZXQtdWkvbGVnYWN5LXBsdWdpbi1jaGFydC1wYXJhbGxlbC1jb29yZGluYXRlcy9lc20vdmVuZG9yL3BhcmNvb3Jkcy9kMy5wYXJjb29yZHMuY3NzP2QyYzQiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi8uLi9jc3MtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTctMSEuL2QzLnBhcmNvb3Jkcy5jc3NcIik7XG5cbmlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xufVxuXG52YXIgb3B0aW9ucyA9IHt9XG5cbm9wdGlvbnMuaW5zZXJ0ID0gXCJoZWFkXCI7XG5vcHRpb25zLnNpbmdsZXRvbiA9IGZhbHNlO1xuXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi8uLi8uLi8uLi8uLi9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcblxuaWYgKGNvbnRlbnQubG9jYWxzKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@superset-ui/legacy-plugin-chart-parallel-coordinates/esm/vendor/parcoords/d3.parcoords.css\n");

/***/ }),

/***/ "./node_modules/@superset-ui/legacy-plugin-chart-parallel-coordinates/esm/vendor/parcoords/d3.parcoords.js":
/*!*****************************************************************************************************************!*\
  !*** ./node_modules/@superset-ui/legacy-plugin-chart-parallel-coordinates/esm/vendor/parcoords/d3.parcoords.js ***!
  \*****************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* [LICENSE TBD] */\n\n/* eslint-disable */\n/* harmony default export */ __webpack_exports__[\"default\"] = (function (config) {\n  var __ = {\n    data: [],\n    highlighted: [],\n    dimensions: [],\n    dimensionTitles: {},\n    dimensionTitleRotation: 0,\n    types: {},\n    brushed: false,\n    brushedColor: null,\n    alphaOnBrushed: 0.0,\n    mode: 'default',\n    rate: 20,\n    width: 600,\n    height: 300,\n    margin: {\n      top: 24,\n      right: 0,\n      bottom: 12,\n      left: 0\n    },\n    nullValueSeparator: 'undefined',\n    // set to \"top\" or \"bottom\"\n    nullValueSeparatorPadding: {\n      top: 8,\n      right: 0,\n      bottom: 8,\n      left: 0\n    },\n    color: '#069',\n    composite: 'source-over',\n    alpha: 0.7,\n    bundlingStrength: 0.5,\n    bundleDimension: null,\n    smoothness: 0.0,\n    showControlPoints: false,\n    hideAxis: []\n  };\n  extend(__, config);\n\n  var pc = function pc(selection) {\n    selection = pc.selection = d3.select(selection);\n    __.width = selection[0][0].clientWidth;\n    __.height = selection[0][0].clientHeight; // canvas data layers\n\n    ['marks', 'foreground', 'brushed', 'highlight'].forEach(function (layer) {\n      canvas[layer] = selection.append('canvas').attr('class', layer)[0][0];\n      ctx[layer] = canvas[layer].getContext('2d');\n    }); // svg tick and brush layers\n\n    pc.svg = selection.append('svg').attr('width', __.width).attr('height', __.height).append('svg:g').attr('transform', 'translate(' + __.margin.left + ',' + __.margin.top + ')');\n    return pc;\n  };\n\n  var events = d3.dispatch.apply(this, ['render', 'resize', 'highlight', 'brush', 'brushend', 'axesreorder'].concat(d3.keys(__))),\n      w = function w() {\n    return __.width - __.margin.right - __.margin.left;\n  },\n      h = function h() {\n    return __.height - __.margin.top - __.margin.bottom;\n  },\n      flags = {\n    brushable: false,\n    reorderable: false,\n    axes: false,\n    interactive: false,\n    debug: false\n  },\n      xscale = d3.scale.ordinal(),\n      yscale = {},\n      dragging = {},\n      line = d3.svg.line(),\n      axis = d3.svg.axis().orient('left').ticks(5),\n      g,\n      // groups for axes, brushes\n  ctx = {},\n      canvas = {},\n      clusterCentroids = []; // side effects for setters\n\n\n  var side_effects = d3.dispatch.apply(this, d3.keys(__)).on('composite', function (d) {\n    ctx.foreground.globalCompositeOperation = d.value;\n    ctx.brushed.globalCompositeOperation = d.value;\n  }).on('alpha', function (d) {\n    ctx.foreground.globalAlpha = d.value;\n    ctx.brushed.globalAlpha = d.value;\n  }).on('brushedColor', function (d) {\n    ctx.brushed.strokeStyle = d.value;\n  }).on('width', function (d) {\n    pc.resize();\n  }).on('height', function (d) {\n    pc.resize();\n  }).on('margin', function (d) {\n    pc.resize();\n  }).on('rate', function (d) {\n    brushedQueue.rate(d.value);\n    foregroundQueue.rate(d.value);\n  }).on('dimensions', function (d) {\n    xscale.domain(__.dimensions);\n\n    if (flags.interactive) {\n      pc.render().updateAxes();\n    }\n  }).on('bundleDimension', function (d) {\n    if (!__.dimensions.length) pc.detectDimensions();\n    if (!(__.dimensions[0] in yscale)) pc.autoscale();\n\n    if (typeof d.value === 'number') {\n      if (d.value < __.dimensions.length) {\n        __.bundleDimension = __.dimensions[d.value];\n      } else if (d.value < __.hideAxis.length) {\n        __.bundleDimension = __.hideAxis[d.value];\n      }\n    } else {\n      __.bundleDimension = d.value;\n    }\n\n    __.clusterCentroids = compute_cluster_centroids(__.bundleDimension);\n  }).on('hideAxis', function (d) {\n    if (!__.dimensions.length) pc.detectDimensions();\n    pc.dimensions(without(__.dimensions, d.value));\n  }); // expose the state of the chart\n\n  pc.state = __;\n  pc.flags = flags; // create getter/setters\n\n  getset(pc, __, events); // expose events\n\n  d3.rebind(pc, events, 'on'); // getter/setter with event firing\n\n  function getset(obj, state, events) {\n    d3.keys(state).forEach(function (key) {\n      obj[key] = function (x) {\n        if (!arguments.length) {\n          return state[key];\n        }\n\n        var old = state[key];\n        state[key] = x;\n        side_effects[key].call(pc, {\n          value: x,\n          previous: old\n        });\n        events[key].call(pc, {\n          value: x,\n          previous: old\n        });\n        return obj;\n      };\n    });\n  }\n\n  function extend(target, source) {\n    for (var key in source) {\n      target[key] = source[key];\n    }\n\n    return target;\n  }\n\n  function without(arr, item) {\n    return arr.filter(function (elem) {\n      return item.indexOf(elem) === -1;\n    });\n  }\n  /** adjusts an axis' default range [h()+1, 1] if a NullValueSeparator is set */\n\n\n  function getRange() {\n    if (__.nullValueSeparator == 'bottom') {\n      return [h() + 1 - __.nullValueSeparatorPadding.bottom - __.nullValueSeparatorPadding.top, 1];\n    } else if (__.nullValueSeparator == 'top') {\n      return [h() + 1, 1 + __.nullValueSeparatorPadding.bottom + __.nullValueSeparatorPadding.top];\n    }\n\n    return [h() + 1, 1];\n  }\n\n  pc.autoscale = function () {\n    // yscale\n    var defaultScales = {\n      date: function date(k) {\n        var extent = d3.extent(__.data, function (d) {\n          return d[k] ? d[k].getTime() : null;\n        }); // special case if single value\n\n        if (extent[0] === extent[1]) {\n          return d3.scale.ordinal().domain([extent[0]]).rangePoints(getRange());\n        }\n\n        return d3.time.scale().domain(extent).range(getRange());\n      },\n      number: function number(k) {\n        var extent = d3.extent(__.data, function (d) {\n          return +d[k];\n        }); // special case if single value\n\n        if (extent[0] === extent[1]) {\n          return d3.scale.ordinal().domain([extent[0]]).rangePoints(getRange());\n        }\n\n        return d3.scale.linear().domain(extent).range(getRange());\n      },\n      string: function string(k) {\n        var counts = {},\n            domain = []; // Let's get the count for each value so that we can sort the domain based\n        // on the number of items for each value.\n\n        __.data.map(function (p) {\n          if (p[k] === undefined && __.nullValueSeparator !== 'undefined') {\n            return; // null values will be drawn beyond the horizontal null value separator!\n          }\n\n          if (counts[p[k]] === undefined) {\n            counts[p[k]] = 1;\n          } else {\n            counts[p[k]] = counts[p[k]] + 1;\n          }\n        });\n\n        domain = Object.getOwnPropertyNames(counts).sort(function (a, b) {\n          return counts[a] - counts[b];\n        });\n        return d3.scale.ordinal().domain(domain).rangePoints(getRange());\n      }\n    };\n\n    __.dimensions.forEach(function (k) {\n      yscale[k] = defaultScales[__.types[k]](k);\n    });\n\n    __.hideAxis.forEach(function (k) {\n      yscale[k] = defaultScales[__.types[k]](k);\n    }); // xscale\n\n\n    xscale.rangePoints([0, w()], 1); // canvas sizes\n\n    pc.selection.selectAll('canvas').style('margin-top', __.margin.top + 'px').style('margin-left', __.margin.left + 'px').attr('width', w() + 2).attr('height', h() + 2); // default styles, needs to be set when canvas width changes\n\n    ctx.foreground.strokeStyle = __.color;\n    ctx.foreground.lineWidth = 1.4;\n    ctx.foreground.globalCompositeOperation = __.composite;\n    ctx.foreground.globalAlpha = __.alpha;\n    ctx.brushed.strokeStyle = __.brushedColor;\n    ctx.brushed.lineWidth = 1.4;\n    ctx.brushed.globalCompositeOperation = __.composite;\n    ctx.brushed.globalAlpha = __.alpha;\n    ctx.highlight.lineWidth = 3;\n    return this;\n  };\n\n  pc.scale = function (d, domain) {\n    yscale[d].domain(domain);\n    return this;\n  };\n\n  pc.flip = function (d) {\n    //yscale[d].domain().reverse();         // does not work\n    yscale[d].domain(yscale[d].domain().reverse()); // works\n\n    return this;\n  };\n\n  pc.commonScale = function (global, type) {\n    var t = type || 'number';\n\n    if (typeof global === 'undefined') {\n      global = true;\n    } // scales of the same type\n\n\n    var scales = __.dimensions.concat(__.hideAxis).filter(function (p) {\n      return __.types[p] == t;\n    });\n\n    if (global) {\n      var extent = d3.extent(scales.map(function (p, i) {\n        return yscale[p].domain();\n      }).reduce(function (a, b) {\n        return a.concat(b);\n      }));\n      scales.forEach(function (d) {\n        yscale[d].domain(extent);\n      });\n    } else {\n      scales.forEach(function (k) {\n        yscale[k].domain(d3.extent(__.data, function (d) {\n          return +d[k];\n        }));\n      });\n    } // update centroids\n\n\n    if (__.bundleDimension !== null) {\n      pc.bundleDimension(__.bundleDimension);\n    }\n\n    return this;\n  };\n\n  pc.detectDimensions = function () {\n    pc.types(pc.detectDimensionTypes(__.data));\n    pc.dimensions(d3.keys(pc.types()));\n    return this;\n  }; // a better \"typeof\" from this post: http://stackoverflow.com/questions/7390426/better-way-to-get-type-of-a-javascript-variable\n\n\n  pc.toType = function (v) {\n    return {}.toString.call(v).match(/\\s([a-zA-Z]+)/)[1].toLowerCase();\n  }; // try to coerce to number before returning type\n\n\n  pc.toTypeCoerceNumbers = function (v) {\n    if (parseFloat(v) == v && v != null) {\n      return 'number';\n    }\n\n    return pc.toType(v);\n  }; // attempt to determine types of each dimension based on first row of data\n\n\n  pc.detectDimensionTypes = function (data) {\n    var types = {};\n    d3.keys(data[0]).forEach(function (col) {\n      types[col] = pc.toTypeCoerceNumbers(data[0][col]);\n    });\n    return types;\n  };\n\n  pc.render = function () {\n    // try to autodetect dimensions and create scales\n    if (!__.dimensions.length) pc.detectDimensions();\n    if (!(__.dimensions[0] in yscale)) pc.autoscale();\n\n    pc.render[__.mode]();\n\n    events.render.call(this);\n    return this;\n  };\n\n  pc.renderBrushed = function () {\n    if (!__.dimensions.length) pc.detectDimensions();\n    if (!(__.dimensions[0] in yscale)) pc.autoscale();\n\n    pc.renderBrushed[__.mode]();\n\n    events.render.call(this);\n    return this;\n  };\n\n  function isBrushed() {\n    if (__.brushed && __.brushed.length !== __.data.length) return true;\n    var object = brush.currentMode().brushState();\n\n    for (var key in object) {\n      if (object.hasOwnProperty(key)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  pc.render.default = function () {\n    pc.clear('foreground');\n    pc.clear('highlight');\n    pc.renderBrushed.default();\n\n    __.data.forEach(path_foreground);\n  };\n\n  var foregroundQueue = d3.renderQueue(path_foreground).rate(50).clear(function () {\n    pc.clear('foreground');\n    pc.clear('highlight');\n  });\n\n  pc.render.queue = function () {\n    pc.renderBrushed.queue();\n    foregroundQueue(__.data);\n  };\n\n  pc.renderBrushed.default = function () {\n    pc.clear('brushed');\n\n    if (isBrushed()) {\n      __.brushed.forEach(path_brushed);\n    }\n  };\n\n  var brushedQueue = d3.renderQueue(path_brushed).rate(50).clear(function () {\n    pc.clear('brushed');\n  });\n\n  pc.renderBrushed.queue = function () {\n    if (isBrushed()) {\n      brushedQueue(__.brushed);\n    } else {\n      brushedQueue([]); // This is needed to clear the currently brushed items\n    }\n  };\n\n  function compute_cluster_centroids(d) {\n    var clusterCentroids = d3.map();\n    var clusterCounts = d3.map(); // determine clusterCounts\n\n    __.data.forEach(function (row) {\n      var scaled = yscale[d](row[d]);\n\n      if (!clusterCounts.has(scaled)) {\n        clusterCounts.set(scaled, 0);\n      }\n\n      var count = clusterCounts.get(scaled);\n      clusterCounts.set(scaled, count + 1);\n    });\n\n    __.data.forEach(function (row) {\n      __.dimensions.map(function (p, i) {\n        var scaled = yscale[d](row[d]);\n\n        if (!clusterCentroids.has(scaled)) {\n          var map = d3.map();\n          clusterCentroids.set(scaled, map);\n        }\n\n        if (!clusterCentroids.get(scaled).has(p)) {\n          clusterCentroids.get(scaled).set(p, 0);\n        }\n\n        var value = clusterCentroids.get(scaled).get(p);\n        value += yscale[p](row[p]) / clusterCounts.get(scaled);\n        clusterCentroids.get(scaled).set(p, value);\n      });\n    });\n\n    return clusterCentroids;\n  }\n\n  function compute_centroids(row) {\n    var centroids = [];\n    var p = __.dimensions;\n    var cols = p.length;\n    var a = 0.5; // center between axes\n\n    for (var i = 0; i < cols; ++i) {\n      // centroids on 'real' axes\n      var x = position(p[i]);\n      var y = yscale[p[i]](row[p[i]]);\n      centroids.push($V([x, y])); // centroids on 'virtual' axes\n\n      if (i < cols - 1) {\n        var cx = x + a * (position(p[i + 1]) - x);\n        var cy = y + a * (yscale[p[i + 1]](row[p[i + 1]]) - y);\n\n        if (__.bundleDimension !== null) {\n          var leftCentroid = __.clusterCentroids.get(yscale[__.bundleDimension](row[__.bundleDimension])).get(p[i]);\n\n          var rightCentroid = __.clusterCentroids.get(yscale[__.bundleDimension](row[__.bundleDimension])).get(p[i + 1]);\n\n          var centroid = 0.5 * (leftCentroid + rightCentroid);\n          cy = centroid + (1 - __.bundlingStrength) * (cy - centroid);\n        }\n\n        centroids.push($V([cx, cy]));\n      }\n    }\n\n    return centroids;\n  }\n\n  function compute_control_points(centroids) {\n    var cols = centroids.length;\n    var a = __.smoothness;\n    var cps = [];\n    cps.push(centroids[0]);\n    cps.push($V([centroids[0].e(1) + a * 2 * (centroids[1].e(1) - centroids[0].e(1)), centroids[0].e(2)]));\n\n    for (var col = 1; col < cols - 1; ++col) {\n      var mid = centroids[col];\n      var left = centroids[col - 1];\n      var right = centroids[col + 1];\n      var diff = left.subtract(right);\n      cps.push(mid.add(diff.x(a)));\n      cps.push(mid);\n      cps.push(mid.subtract(diff.x(a)));\n    }\n\n    cps.push($V([centroids[cols - 1].e(1) + a * 2 * (centroids[cols - 2].e(1) - centroids[cols - 1].e(1)), centroids[cols - 1].e(2)]));\n    cps.push(centroids[cols - 1]);\n    return cps;\n  }\n\n  pc.shadows = function () {\n    flags.shadows = true;\n    pc.alphaOnBrushed(0.1);\n    pc.render();\n    return this;\n  }; // draw dots with radius r on the axis line where data intersects\n\n\n  pc.axisDots = function (r) {\n    var r = r || 0.1;\n    var ctx = pc.ctx.marks;\n    var startAngle = 0;\n    var endAngle = 2 * Math.PI;\n    ctx.globalAlpha = d3.min([1 / Math.pow(__.data.length, 1 / 2), 1]);\n\n    __.data.forEach(function (d) {\n      __.dimensions.map(function (p, i) {\n        ctx.beginPath();\n        ctx.arc(position(p), yscale[p](d[p]), r, startAngle, endAngle);\n        ctx.stroke();\n        ctx.fill();\n      });\n    });\n\n    return this;\n  }; // draw single cubic bezier curve\n\n\n  function single_curve(d, ctx) {\n    var centroids = compute_centroids(d);\n    var cps = compute_control_points(centroids);\n    ctx.moveTo(cps[0].e(1), cps[0].e(2));\n\n    for (var i = 1; i < cps.length; i += 3) {\n      if (__.showControlPoints) {\n        for (var j = 0; j < 3; j++) {\n          ctx.fillRect(cps[i + j].e(1), cps[i + j].e(2), 2, 2);\n        }\n      }\n\n      ctx.bezierCurveTo(cps[i].e(1), cps[i].e(2), cps[i + 1].e(1), cps[i + 1].e(2), cps[i + 2].e(1), cps[i + 2].e(2));\n    }\n  } // draw single polyline\n\n\n  function color_path(d, ctx) {\n    ctx.beginPath();\n\n    if (__.bundleDimension !== null && __.bundlingStrength > 0 || __.smoothness > 0) {\n      single_curve(d, ctx);\n    } else {\n      single_path(d, ctx);\n    }\n\n    ctx.stroke();\n  } // draw many polylines of the same color\n\n\n  function paths(data, ctx) {\n    ctx.clearRect(-1, -1, w() + 2, h() + 2);\n    ctx.beginPath();\n    data.forEach(function (d) {\n      if (__.bundleDimension !== null && __.bundlingStrength > 0 || __.smoothness > 0) {\n        single_curve(d, ctx);\n      } else {\n        single_path(d, ctx);\n      }\n    });\n    ctx.stroke();\n  } // returns the y-position just beyond the separating null value line\n\n\n  function getNullPosition() {\n    if (__.nullValueSeparator == 'bottom') {\n      return h() + 1;\n    } else if (__.nullValueSeparator == 'top') {\n      return 1;\n    } else {\n      console.log(\"A value is NULL, but nullValueSeparator is not set; set it to 'bottom' or 'top'.\");\n    }\n\n    return h() + 1;\n  }\n\n  function single_path(d, ctx) {\n    __.dimensions.map(function (p, i) {\n      if (i == 0) {\n        ctx.moveTo(position(p), typeof d[p] == 'undefined' ? getNullPosition() : yscale[p](d[p]));\n      } else {\n        ctx.lineTo(position(p), typeof d[p] == 'undefined' ? getNullPosition() : yscale[p](d[p]));\n      }\n    });\n  }\n\n  function path_brushed(d, i) {\n    if (__.brushedColor !== null) {\n      ctx.brushed.strokeStyle = d3.functor(__.brushedColor)(d, i);\n    } else {\n      ctx.brushed.strokeStyle = d3.functor(__.color)(d, i);\n    }\n\n    return color_path(d, ctx.brushed);\n  }\n\n  function path_foreground(d, i) {\n    ctx.foreground.strokeStyle = d3.functor(__.color)(d, i);\n    return color_path(d, ctx.foreground);\n  }\n\n  function path_highlight(d, i) {\n    ctx.highlight.strokeStyle = d3.functor(__.color)(d, i);\n    return color_path(d, ctx.highlight);\n  }\n\n  pc.clear = function (layer) {\n    ctx[layer].clearRect(0, 0, w() + 2, h() + 2); // This will make sure that the foreground items are transparent\n    // without the need for changing the opacity style of the foreground canvas\n    // as this would stop the css styling from working\n\n    if (layer === 'brushed' && isBrushed()) {\n      ctx.brushed.fillStyle = pc.selection.style('background-color');\n      ctx.brushed.globalAlpha = 1 - __.alphaOnBrushed;\n      ctx.brushed.fillRect(0, 0, w() + 2, h() + 2);\n      ctx.brushed.globalAlpha = __.alpha;\n    }\n\n    return this;\n  };\n\n  d3.rebind(pc, axis, 'ticks', 'orient', 'tickValues', 'tickSubdivide', 'tickSize', 'tickPadding', 'tickFormat');\n\n  function flipAxisAndUpdatePCP(dimension) {\n    var g = pc.svg.selectAll('.dimension');\n    pc.flip(dimension);\n    d3.select(this.parentElement).transition().duration(1100).call(axis.scale(yscale[dimension]));\n    pc.render();\n  }\n\n  function rotateLabels() {\n    var delta = d3.event.deltaY;\n    delta = delta < 0 ? -5 : delta;\n    delta = delta > 0 ? 5 : delta;\n    __.dimensionTitleRotation += delta;\n    pc.svg.selectAll('text.label').attr('transform', 'translate(0,-5) rotate(' + __.dimensionTitleRotation + ')');\n    d3.event.preventDefault();\n  }\n\n  function dimensionLabels(d) {\n    return d in __.dimensionTitles ? __.dimensionTitles[d] : d; // dimension display names\n  }\n\n  pc.createAxes = function () {\n    if (g) pc.removeAxes(); // Add a group element for each dimension.\n\n    g = pc.svg.selectAll('.dimension').data(__.dimensions, function (d) {\n      return d;\n    }).enter().append('svg:g').attr('class', 'dimension').attr('transform', function (d) {\n      return 'translate(' + xscale(d) + ')';\n    }); // Add an axis and title.\n\n    g.append('svg:g').attr('class', 'axis').attr('transform', 'translate(0,0)').each(function (d) {\n      d3.select(this).call(axis.scale(yscale[d]));\n    }).append('svg:text').attr({\n      'text-anchor': 'middle',\n      y: 0,\n      transform: 'translate(0,-5) rotate(' + __.dimensionTitleRotation + ')',\n      x: 0,\n      class: 'label'\n    }).text(dimensionLabels).on('dblclick', flipAxisAndUpdatePCP).on('wheel', rotateLabels);\n\n    if (__.nullValueSeparator == 'top') {\n      pc.svg.append('line').attr('x1', 0).attr('y1', 1 + __.nullValueSeparatorPadding.top).attr('x2', w()).attr('y2', 1 + __.nullValueSeparatorPadding.top).attr('stroke-width', 1).attr('stroke', '#777').attr('fill', 'none').attr('shape-rendering', 'crispEdges');\n    } else if (__.nullValueSeparator == 'bottom') {\n      pc.svg.append('line').attr('x1', 0).attr('y1', h() + 1 - __.nullValueSeparatorPadding.bottom).attr('x2', w()).attr('y2', h() + 1 - __.nullValueSeparatorPadding.bottom).attr('stroke-width', 1).attr('stroke', '#777').attr('fill', 'none').attr('shape-rendering', 'crispEdges');\n    }\n\n    flags.axes = true;\n    return this;\n  };\n\n  pc.removeAxes = function () {\n    g.remove();\n    return this;\n  };\n\n  pc.updateAxes = function () {\n    var g_data = pc.svg.selectAll('.dimension').data(__.dimensions); // Enter\n\n    g_data.enter().append('svg:g').attr('class', 'dimension').attr('transform', function (p) {\n      return 'translate(' + position(p) + ')';\n    }).style('opacity', 0).append('svg:g').attr('class', 'axis').attr('transform', 'translate(0,0)').each(function (d) {\n      d3.select(this).call(axis.scale(yscale[d]));\n    }).append('svg:text').attr({\n      'text-anchor': 'middle',\n      y: 0,\n      transform: 'translate(0,-5) rotate(' + __.dimensionTitleRotation + ')',\n      x: 0,\n      class: 'label'\n    }).text(dimensionLabels).on('dblclick', flipAxisAndUpdatePCP).on('wheel', rotateLabels); // Update\n\n    g_data.attr('opacity', 0);\n    g_data.select('.axis').transition().duration(1100).each(function (d) {\n      d3.select(this).call(axis.scale(yscale[d]));\n    });\n    g_data.select('.label').transition().duration(1100).text(dimensionLabels).attr('transform', 'translate(0,-5) rotate(' + __.dimensionTitleRotation + ')'); // Exit\n\n    g_data.exit().remove();\n    g = pc.svg.selectAll('.dimension');\n    g.transition().duration(1100).attr('transform', function (p) {\n      return 'translate(' + position(p) + ')';\n    }).style('opacity', 1);\n    pc.svg.selectAll('.axis').transition().duration(1100).each(function (d) {\n      d3.select(this).call(axis.scale(yscale[d]));\n    });\n    if (flags.brushable) pc.brushable();\n    if (flags.reorderable) pc.reorderable();\n\n    if (pc.brushMode() !== 'None') {\n      var mode = pc.brushMode();\n      pc.brushMode('None');\n      pc.brushMode(mode);\n    }\n\n    return this;\n  }; // Jason Davies, http://bl.ocks.org/1341281\n\n\n  pc.reorderable = function () {\n    if (!g) pc.createAxes();\n    g.style('cursor', 'move').call(d3.behavior.drag().on('dragstart', function (d) {\n      dragging[d] = this.__origin__ = xscale(d);\n    }).on('drag', function (d) {\n      dragging[d] = Math.min(w(), Math.max(0, this.__origin__ += d3.event.dx));\n\n      __.dimensions.sort(function (a, b) {\n        return position(a) - position(b);\n      });\n\n      xscale.domain(__.dimensions);\n      pc.render();\n      g.attr('transform', function (d) {\n        return 'translate(' + position(d) + ')';\n      });\n    }).on('dragend', function (d) {\n      // Let's see if the order has changed and send out an event if so.\n      var i = 0,\n          j = __.dimensions.indexOf(d),\n          elem = this,\n          parent = this.parentElement;\n\n      while ((elem = elem.previousElementSibling) != null) ++i;\n\n      if (i !== j) {\n        events.axesreorder.call(pc, __.dimensions); // We now also want to reorder the actual dom elements that represent\n        // the axes. That is, the g.dimension elements. If we don't do this,\n        // we get a weird and confusing transition when updateAxes is called.\n        // This is due to the fact that, initially the nth g.dimension element\n        // represents the nth axis. However, after a manual reordering,\n        // without reordering the dom elements, the nth dom elements no longer\n        // necessarily represents the nth axis.\n        //\n        // i is the original index of the dom element\n        // j is the new index of the dom element\n\n        if (i > j) {\n          // Element moved left\n          parent.insertBefore(this, parent.children[j - 1]);\n        } else {\n          // Element moved right\n          if (j + 1 < parent.children.length) {\n            parent.insertBefore(this, parent.children[j + 1]);\n          } else {\n            parent.appendChild(this);\n          }\n        }\n      }\n\n      delete this.__origin__;\n      delete dragging[d];\n      d3.select(this).transition().attr('transform', 'translate(' + xscale(d) + ')');\n      pc.render();\n    }));\n    flags.reorderable = true;\n    return this;\n  }; // Reorder dimensions, such that the highest value (visually) is on the left and\n  // the lowest on the right. Visual values are determined by the data values in\n  // the given row.\n\n\n  pc.reorder = function (rowdata) {\n    var dims = __.dimensions.slice(0);\n\n    __.dimensions.sort(function (a, b) {\n      var pixelDifference = yscale[a](rowdata[a]) - yscale[b](rowdata[b]); // Array.sort is not necessarily stable, this means that if pixelDifference is zero\n      // the ordering of dimensions might change unexpectedly. This is solved by sorting on\n      // variable name in that case.\n\n      if (pixelDifference === 0) {\n        return a.localeCompare(b);\n      } // else\n\n\n      return pixelDifference;\n    }); // NOTE: this is relatively cheap given that:\n    // number of dimensions < number of data items\n    // Thus we check equality of order to prevent rerendering when this is the case.\n\n\n    var reordered = false;\n    dims.some(function (val, index) {\n      reordered = val !== __.dimensions[index];\n      return reordered;\n    });\n\n    if (reordered) {\n      xscale.domain(__.dimensions);\n\n      var highlighted = __.highlighted.slice(0);\n\n      pc.unhighlight();\n      g.transition().duration(1500).attr('transform', function (d) {\n        return 'translate(' + xscale(d) + ')';\n      });\n      pc.render(); // pc.highlight() does not check whether highlighted is length zero, so we do that here.\n\n      if (highlighted.length !== 0) {\n        pc.highlight(highlighted);\n      }\n    }\n  }; // pairs of adjacent dimensions\n\n\n  pc.adjacent_pairs = function (arr) {\n    var ret = [];\n\n    for (var i = 0; i < arr.length - 1; i++) {\n      ret.push([arr[i], arr[i + 1]]);\n    }\n\n    return ret;\n  };\n\n  var brush = {\n    modes: {\n      None: {\n        install: function install(pc) {},\n        // Nothing to be done.\n        uninstall: function uninstall(pc) {},\n        // Nothing to be done.\n        selected: function selected() {\n          return [];\n        },\n        // Nothing to return\n        brushState: function brushState() {\n          return {};\n        }\n      }\n    },\n    mode: 'None',\n    predicate: 'AND',\n    currentMode: function currentMode() {\n      return this.modes[this.mode];\n    }\n  }; // This function can be used for 'live' updates of brushes. That is, during the\n  // specification of a brush, this method can be called to update the view.\n  //\n  // @param newSelection - The new set of data items that is currently contained\n  //                       by the brushes\n\n  function brushUpdated(newSelection) {\n    __.brushed = newSelection;\n    events.brush.call(pc, __.brushed);\n    pc.renderBrushed();\n  }\n\n  function brushPredicate(predicate) {\n    if (!arguments.length) {\n      return brush.predicate;\n    }\n\n    predicate = String(predicate).toUpperCase();\n\n    if (predicate !== 'AND' && predicate !== 'OR') {\n      throw 'Invalid predicate ' + predicate;\n    }\n\n    brush.predicate = predicate;\n    __.brushed = brush.currentMode().selected();\n    pc.renderBrushed();\n    return pc;\n  }\n\n  pc.brushModes = function () {\n    return Object.getOwnPropertyNames(brush.modes);\n  };\n\n  pc.brushMode = function (mode) {\n    if (arguments.length === 0) {\n      return brush.mode;\n    }\n\n    if (pc.brushModes().indexOf(mode) === -1) {\n      throw 'pc.brushmode: Unsupported brush mode: ' + mode;\n    } // Make sure that we don't trigger unnecessary events by checking if the mode\n    // actually changes.\n\n\n    if (mode !== brush.mode) {\n      // When changing brush modes, the first thing we need to do is clearing any\n      // brushes from the current mode, if any.\n      if (brush.mode !== 'None') {\n        pc.brushReset();\n      } // Next, we need to 'uninstall' the current brushMode.\n\n\n      brush.modes[brush.mode].uninstall(pc); // Finally, we can install the requested one.\n\n      brush.mode = mode;\n      brush.modes[brush.mode].install();\n\n      if (mode === 'None') {\n        delete pc.brushPredicate;\n      } else {\n        pc.brushPredicate = brushPredicate;\n      }\n    }\n\n    return pc;\n  }; // brush mode: 1D-Axes\n\n\n  (function () {\n    var brushes = {};\n\n    function is_brushed(p) {\n      return !brushes[p].empty();\n    } // data within extents\n\n\n    function selected() {\n      var actives = __.dimensions.filter(is_brushed),\n          extents = actives.map(function (p) {\n        return brushes[p].extent();\n      }); // We don't want to return the full data set when there are no axes brushed.\n      // Actually, when there are no axes brushed, by definition, no items are\n      // selected. So, let's avoid the filtering and just return false.\n      //if (actives.length === 0) return false;\n      // Resolves broken examples for now. They expect to get the full dataset back from empty brushes\n\n\n      if (actives.length === 0) return __.data; // test if within range\n\n      var within = {\n        date: function date(d, p, dimension) {\n          if (typeof yscale[p].rangePoints === 'function') {\n            // if it is ordinal\n            return extents[dimension][0] <= yscale[p](d[p]) && yscale[p](d[p]) <= extents[dimension][1];\n          } else {\n            return extents[dimension][0] <= d[p] && d[p] <= extents[dimension][1];\n          }\n        },\n        number: function number(d, p, dimension) {\n          if (typeof yscale[p].rangePoints === 'function') {\n            // if it is ordinal\n            return extents[dimension][0] <= yscale[p](d[p]) && yscale[p](d[p]) <= extents[dimension][1];\n          } else {\n            return extents[dimension][0] <= d[p] && d[p] <= extents[dimension][1];\n          }\n        },\n        string: function string(d, p, dimension) {\n          return extents[dimension][0] <= yscale[p](d[p]) && yscale[p](d[p]) <= extents[dimension][1];\n        }\n      };\n      return __.data.filter(function (d) {\n        switch (brush.predicate) {\n          case 'AND':\n            return actives.every(function (p, dimension) {\n              return within[__.types[p]](d, p, dimension);\n            });\n\n          case 'OR':\n            return actives.some(function (p, dimension) {\n              return within[__.types[p]](d, p, dimension);\n            });\n\n          default:\n            throw 'Unknown brush predicate ' + __.brushPredicate;\n        }\n      });\n    }\n\n    function brushExtents(extents) {\n      if (typeof extents === 'undefined') {\n        var extents = {};\n\n        __.dimensions.forEach(function (d) {\n          var brush = brushes[d];\n\n          if (brush !== undefined && !brush.empty()) {\n            var extent = brush.extent();\n            extent.sort(d3.ascending);\n            extents[d] = extent;\n          }\n        });\n\n        return extents;\n      } else {\n        //first get all the brush selections\n        var brushSelections = {};\n        g.selectAll('.brush').each(function (d) {\n          brushSelections[d] = d3.select(this);\n        }); // loop over each dimension and update appropriately (if it was passed in through extents)\n\n        __.dimensions.forEach(function (d) {\n          if (extents[d] === undefined) {\n            return;\n          }\n\n          var brush = brushes[d];\n\n          if (brush !== undefined) {\n            //update the extent\n            brush.extent(extents[d]); //redraw the brush\n\n            brush(brushSelections[d]); //fire some events\n\n            brush.event(brushSelections[d]);\n          }\n        }); //redraw the chart\n\n\n        pc.renderBrushed();\n      }\n    }\n\n    function brushFor(axis) {\n      var brush = d3.svg.brush();\n      brush.y(yscale[axis]).on('brushstart', function () {\n        if (d3.event.sourceEvent !== null) {\n          d3.event.sourceEvent.stopPropagation();\n        }\n      }).on('brush', function () {\n        brushUpdated(selected());\n      }).on('brushend', function () {\n        events.brushend.call(pc, __.brushed);\n      });\n      brushes[axis] = brush;\n      return brush;\n    }\n\n    function brushReset(dimension) {\n      __.brushed = false;\n\n      if (g) {\n        g.selectAll('.brush').each(function (d) {\n          d3.select(this).call(brushes[d].clear());\n        });\n        pc.renderBrushed();\n      }\n\n      return this;\n    }\n\n    function install() {\n      if (!g) pc.createAxes(); // Add and store a brush for each axis.\n\n      g.append('svg:g').attr('class', 'brush').each(function (d) {\n        d3.select(this).call(brushFor(d));\n      }).selectAll('rect').style('visibility', null).attr('x', -15).attr('width', 30);\n      pc.brushExtents = brushExtents;\n      pc.brushReset = brushReset;\n      return pc;\n    }\n\n    brush.modes['1D-axes'] = {\n      install: install,\n      uninstall: function uninstall() {\n        g.selectAll('.brush').remove();\n        brushes = {};\n        delete pc.brushExtents;\n        delete pc.brushReset;\n      },\n      selected: selected,\n      brushState: brushExtents\n    };\n  })(); // brush mode: 2D-strums\n  // bl.ocks.org/syntagmatic/5441022\n\n\n  (function () {\n    var strums = {},\n        strumRect;\n\n    function drawStrum(strum, activePoint) {\n      var svg = pc.selection.select('svg').select('g#strums'),\n          id = strum.dims.i,\n          points = [strum.p1, strum.p2],\n          line = svg.selectAll('line#strum-' + id).data([strum]),\n          circles = svg.selectAll('circle#strum-' + id).data(points),\n          drag = d3.behavior.drag();\n      line.enter().append('line').attr('id', 'strum-' + id).attr('class', 'strum');\n      line.attr('x1', function (d) {\n        return d.p1[0];\n      }).attr('y1', function (d) {\n        return d.p1[1];\n      }).attr('x2', function (d) {\n        return d.p2[0];\n      }).attr('y2', function (d) {\n        return d.p2[1];\n      }).attr('stroke', 'black').attr('stroke-width', 2);\n      drag.on('drag', function (d, i) {\n        var ev = d3.event;\n        i = i + 1;\n        strum['p' + i][0] = Math.min(Math.max(strum.minX + 1, ev.x), strum.maxX);\n        strum['p' + i][1] = Math.min(Math.max(strum.minY, ev.y), strum.maxY);\n        drawStrum(strum, i - 1);\n      }).on('dragend', onDragEnd());\n      circles.enter().append('circle').attr('id', 'strum-' + id).attr('class', 'strum');\n      circles.attr('cx', function (d) {\n        return d[0];\n      }).attr('cy', function (d) {\n        return d[1];\n      }).attr('r', 5).style('opacity', function (d, i) {\n        return activePoint !== undefined && i === activePoint ? 0.8 : 0;\n      }).on('mouseover', function () {\n        d3.select(this).style('opacity', 0.8);\n      }).on('mouseout', function () {\n        d3.select(this).style('opacity', 0);\n      }).call(drag);\n    }\n\n    function dimensionsForPoint(p) {\n      var dims = {\n        i: -1,\n        left: undefined,\n        right: undefined\n      };\n\n      __.dimensions.some(function (dim, i) {\n        if (xscale(dim) < p[0]) {\n          var next = __.dimensions[i + 1];\n          dims.i = i;\n          dims.left = dim;\n          dims.right = next;\n          return false;\n        }\n\n        return true;\n      });\n\n      if (dims.left === undefined) {\n        // Event on the left side of the first axis.\n        dims.i = 0;\n        dims.left = __.dimensions[0];\n        dims.right = __.dimensions[1];\n      } else if (dims.right === undefined) {\n        // Event on the right side of the last axis\n        dims.i = __.dimensions.length - 1;\n        dims.right = dims.left;\n        dims.left = __.dimensions[__.dimensions.length - 2];\n      }\n\n      return dims;\n    }\n\n    function onDragStart() {\n      // First we need to determine between which two axes the sturm was started.\n      // This will determine the freedom of movement, because a strum can\n      // logically only happen between two axes, so no movement outside these axes\n      // should be allowed.\n      return function () {\n        var p = d3.mouse(strumRect[0][0]),\n            dims,\n            strum;\n        p[0] = p[0] - __.margin.left;\n        p[1] = p[1] - __.margin.top;\n        dims = dimensionsForPoint(p), strum = {\n          p1: p,\n          dims: dims,\n          minX: xscale(dims.left),\n          maxX: xscale(dims.right),\n          minY: 0,\n          maxY: h()\n        };\n        strums[dims.i] = strum;\n        strums.active = dims.i; // Make sure that the point is within the bounds\n\n        strum.p1[0] = Math.min(Math.max(strum.minX, p[0]), strum.maxX);\n        strum.p2 = strum.p1.slice();\n      };\n    }\n\n    function onDrag() {\n      return function () {\n        var ev = d3.event,\n            strum = strums[strums.active]; // Make sure that the point is within the bounds\n\n        strum.p2[0] = Math.min(Math.max(strum.minX + 1, ev.x - __.margin.left), strum.maxX);\n        strum.p2[1] = Math.min(Math.max(strum.minY, ev.y - __.margin.top), strum.maxY);\n        drawStrum(strum, 1);\n      };\n    }\n\n    function containmentTest(strum, width) {\n      var p1 = [strum.p1[0] - strum.minX, strum.p1[1] - strum.minX],\n          p2 = [strum.p2[0] - strum.minX, strum.p2[1] - strum.minX],\n          m1 = 1 - width / p1[0],\n          b1 = p1[1] * (1 - m1),\n          m2 = 1 - width / p2[0],\n          b2 = p2[1] * (1 - m2); // test if point falls between lines\n\n      return function (p) {\n        var x = p[0],\n            y = p[1],\n            y1 = m1 * x + b1,\n            y2 = m2 * x + b2;\n\n        if (y > Math.min(y1, y2) && y < Math.max(y1, y2)) {\n          return true;\n        }\n\n        return false;\n      };\n    }\n\n    function selected() {\n      var ids = Object.getOwnPropertyNames(strums),\n          brushed = __.data; // Get the ids of the currently active strums.\n\n      ids = ids.filter(function (d) {\n        return !isNaN(d);\n      });\n\n      function crossesStrum(d, id) {\n        var strum = strums[id],\n            test = containmentTest(strum, strums.width(id)),\n            d1 = strum.dims.left,\n            d2 = strum.dims.right,\n            y1 = yscale[d1],\n            y2 = yscale[d2],\n            point = [y1(d[d1]) - strum.minX, y2(d[d2]) - strum.minX];\n        return test(point);\n      }\n\n      if (ids.length === 0) {\n        return brushed;\n      }\n\n      return brushed.filter(function (d) {\n        switch (brush.predicate) {\n          case 'AND':\n            return ids.every(function (id) {\n              return crossesStrum(d, id);\n            });\n\n          case 'OR':\n            return ids.some(function (id) {\n              return crossesStrum(d, id);\n            });\n\n          default:\n            throw 'Unknown brush predicate ' + __.brushPredicate;\n        }\n      });\n    }\n\n    function removeStrum() {\n      var strum = strums[strums.active],\n          svg = pc.selection.select('svg').select('g#strums');\n      delete strums[strums.active];\n      strums.active = undefined;\n      svg.selectAll('line#strum-' + strum.dims.i).remove();\n      svg.selectAll('circle#strum-' + strum.dims.i).remove();\n    }\n\n    function onDragEnd() {\n      return function () {\n        var brushed = __.data,\n            strum = strums[strums.active]; // Okay, somewhat unexpected, but not totally unsurprising, a mousclick is\n        // considered a drag without move. So we have to deal with that case\n\n        if (strum && strum.p1[0] === strum.p2[0] && strum.p1[1] === strum.p2[1]) {\n          removeStrum(strums);\n        }\n\n        brushed = selected(strums);\n        strums.active = undefined;\n        __.brushed = brushed;\n        pc.renderBrushed();\n        events.brushend.call(pc, __.brushed);\n      };\n    }\n\n    function brushReset(strums) {\n      return function () {\n        var ids = Object.getOwnPropertyNames(strums).filter(function (d) {\n          return !isNaN(d);\n        });\n        ids.forEach(function (d) {\n          strums.active = d;\n          removeStrum(strums);\n        });\n        onDragEnd(strums)();\n      };\n    }\n\n    function install() {\n      var drag = d3.behavior.drag(); // Map of current strums. Strums are stored per segment of the PC. A segment,\n      // being the area between two axes. The left most area is indexed at 0.\n\n      strums.active = undefined; // Returns the width of the PC segment where currently a strum is being\n      // placed. NOTE: even though they are evenly spaced in our current\n      // implementation, we keep for when non-even spaced segments are supported as\n      // well.\n\n      strums.width = function (id) {\n        var strum = strums[id];\n\n        if (strum === undefined) {\n          return undefined;\n        }\n\n        return strum.maxX - strum.minX;\n      };\n\n      pc.on('axesreorder.strums', function () {\n        var ids = Object.getOwnPropertyNames(strums).filter(function (d) {\n          return !isNaN(d);\n        }); // Checks if the first dimension is directly left of the second dimension.\n\n        function consecutive(first, second) {\n          var length = __.dimensions.length;\n          return __.dimensions.some(function (d, i) {\n            return d === first ? i + i < length && __.dimensions[i + 1] === second : false;\n          });\n        }\n\n        if (ids.length > 0) {\n          // We have some strums, which might need to be removed.\n          ids.forEach(function (d) {\n            var dims = strums[d].dims;\n            strums.active = d; // If the two dimensions of the current strum are not next to each other\n            // any more, than we'll need to remove the strum. Otherwise we keep it.\n\n            if (!consecutive(dims.left, dims.right)) {\n              removeStrum(strums);\n            }\n          });\n          onDragEnd(strums)();\n        }\n      }); // Add a new svg group in which we draw the strums.\n\n      pc.selection.select('svg').append('g').attr('id', 'strums').attr('transform', 'translate(' + __.margin.left + ',' + __.margin.top + ')'); // Install the required brushReset function\n\n      pc.brushReset = brushReset(strums);\n      drag.on('dragstart', onDragStart(strums)).on('drag', onDrag(strums)).on('dragend', onDragEnd(strums)); // NOTE: The styling needs to be done here and not in the css. This is because\n      //       for 1D brushing, the canvas layers should not listen to\n      //       pointer-events.\n\n      strumRect = pc.selection.select('svg').insert('rect', 'g#strums').attr('id', 'strum-events').attr('x', __.margin.left).attr('y', __.margin.top).attr('width', w()).attr('height', h() + 2).style('opacity', 0).call(drag);\n    }\n\n    brush.modes['2D-strums'] = {\n      install: install,\n      uninstall: function uninstall() {\n        pc.selection.select('svg').select('g#strums').remove();\n        pc.selection.select('svg').select('rect#strum-events').remove();\n        pc.on('axesreorder.strums', undefined);\n        delete pc.brushReset;\n        strumRect = undefined;\n      },\n      selected: selected,\n      brushState: function brushState() {\n        return strums;\n      }\n    };\n  })(); // brush mode: 1D-Axes with multiple extents\n  // requires d3.svg.multibrush\n\n\n  (function () {\n    if (typeof d3.svg.multibrush !== 'function') {\n      return;\n    }\n\n    var brushes = {};\n\n    function is_brushed(p) {\n      return !brushes[p].empty();\n    } // data within extents\n\n\n    function selected() {\n      var actives = __.dimensions.filter(is_brushed),\n          extents = actives.map(function (p) {\n        return brushes[p].extent();\n      }); // We don't want to return the full data set when there are no axes brushed.\n      // Actually, when there are no axes brushed, by definition, no items are\n      // selected. So, let's avoid the filtering and just return false.\n      //if (actives.length === 0) return false;\n      // Resolves broken examples for now. They expect to get the full dataset back from empty brushes\n\n\n      if (actives.length === 0) return __.data; // test if within range\n\n      var within = {\n        date: function date(d, p, dimension, b) {\n          if (typeof yscale[p].rangePoints === 'function') {\n            // if it is ordinal\n            return b[0] <= yscale[p](d[p]) && yscale[p](d[p]) <= b[1];\n          } else {\n            return b[0] <= d[p] && d[p] <= b[1];\n          }\n        },\n        number: function number(d, p, dimension, b) {\n          if (typeof yscale[p].rangePoints === 'function') {\n            // if it is ordinal\n            return b[0] <= yscale[p](d[p]) && yscale[p](d[p]) <= b[1];\n          } else {\n            return b[0] <= d[p] && d[p] <= b[1];\n          }\n        },\n        string: function string(d, p, dimension, b) {\n          return b[0] <= yscale[p](d[p]) && yscale[p](d[p]) <= b[1];\n        }\n      };\n      return __.data.filter(function (d) {\n        switch (brush.predicate) {\n          case 'AND':\n            return actives.every(function (p, dimension) {\n              return extents[dimension].some(function (b) {\n                return within[__.types[p]](d, p, dimension, b);\n              });\n            });\n\n          case 'OR':\n            return actives.some(function (p, dimension) {\n              return extents[dimension].some(function (b) {\n                return within[__.types[p]](d, p, dimension, b);\n              });\n            });\n\n          default:\n            throw 'Unknown brush predicate ' + __.brushPredicate;\n        }\n      });\n    }\n\n    function brushExtents() {\n      var extents = {};\n\n      __.dimensions.forEach(function (d) {\n        var brush = brushes[d];\n\n        if (brush !== undefined && !brush.empty()) {\n          var extent = brush.extent();\n          extents[d] = extent;\n        }\n      });\n\n      return extents;\n    }\n\n    function brushFor(axis) {\n      var brush = d3.svg.multibrush();\n      brush.y(yscale[axis]).on('brushstart', function () {\n        if (d3.event.sourceEvent !== null) {\n          d3.event.sourceEvent.stopPropagation();\n        }\n      }).on('brush', function () {\n        brushUpdated(selected());\n      }).on('brushend', function () {\n        // d3.svg.multibrush clears extents just before calling 'brushend'\n        // so we have to update here again.\n        // This fixes issue #103 for now, but should be changed in d3.svg.multibrush\n        // to avoid unnecessary computation.\n        brushUpdated(selected());\n        events.brushend.call(pc, __.brushed);\n      }).extentAdaption(function (selection) {\n        selection.style('visibility', null).attr('x', -15).attr('width', 30);\n      }).resizeAdaption(function (selection) {\n        selection.selectAll('rect').attr('x', -15).attr('width', 30);\n      });\n      brushes[axis] = brush;\n      return brush;\n    }\n\n    function brushReset(dimension) {\n      __.brushed = false;\n\n      if (g) {\n        g.selectAll('.brush').each(function (d) {\n          d3.select(this).call(brushes[d].clear());\n        });\n        pc.renderBrushed();\n      }\n\n      return this;\n    }\n\n    function install() {\n      if (!g) pc.createAxes(); // Add and store a brush for each axis.\n\n      g.append('svg:g').attr('class', 'brush').each(function (d) {\n        d3.select(this).call(brushFor(d));\n      }).selectAll('rect').style('visibility', null).attr('x', -15).attr('width', 30);\n      pc.brushExtents = brushExtents;\n      pc.brushReset = brushReset;\n      return pc;\n    }\n\n    brush.modes['1D-axes-multi'] = {\n      install: install,\n      uninstall: function uninstall() {\n        g.selectAll('.brush').remove();\n        brushes = {};\n        delete pc.brushExtents;\n        delete pc.brushReset;\n      },\n      selected: selected,\n      brushState: brushExtents\n    };\n  })(); // brush mode: angular\n  // code based on 2D.strums.js\n\n\n  (function () {\n    var arcs = {},\n        strumRect;\n\n    function drawStrum(arc, activePoint) {\n      var svg = pc.selection.select('svg').select('g#arcs'),\n          id = arc.dims.i,\n          points = [arc.p2, arc.p3],\n          line = svg.selectAll('line#arc-' + id).data([{\n        p1: arc.p1,\n        p2: arc.p2\n      }, {\n        p1: arc.p1,\n        p2: arc.p3\n      }]),\n          circles = svg.selectAll('circle#arc-' + id).data(points),\n          drag = d3.behavior.drag(),\n          path = svg.selectAll('path#arc-' + id).data([arc]);\n      path.enter().append('path').attr('id', 'arc-' + id).attr('class', 'arc').style('fill', 'orange').style('opacity', 0.5);\n      path.attr('d', arc.arc).attr('transform', 'translate(' + arc.p1[0] + ',' + arc.p1[1] + ')');\n      line.enter().append('line').attr('id', 'arc-' + id).attr('class', 'arc');\n      line.attr('x1', function (d) {\n        return d.p1[0];\n      }).attr('y1', function (d) {\n        return d.p1[1];\n      }).attr('x2', function (d) {\n        return d.p2[0];\n      }).attr('y2', function (d) {\n        return d.p2[1];\n      }).attr('stroke', 'black').attr('stroke-width', 2);\n      drag.on('drag', function (d, i) {\n        var ev = d3.event,\n            angle = 0;\n        i = i + 2;\n        arc['p' + i][0] = Math.min(Math.max(arc.minX + 1, ev.x), arc.maxX);\n        arc['p' + i][1] = Math.min(Math.max(arc.minY, ev.y), arc.maxY);\n        angle = i === 3 ? arcs.startAngle(id) : arcs.endAngle(id);\n\n        if (arc.startAngle < Math.PI && arc.endAngle < Math.PI && angle < Math.PI || arc.startAngle >= Math.PI && arc.endAngle >= Math.PI && angle >= Math.PI) {\n          if (i === 2) {\n            arc.endAngle = angle;\n            arc.arc.endAngle(angle);\n          } else if (i === 3) {\n            arc.startAngle = angle;\n            arc.arc.startAngle(angle);\n          }\n        }\n\n        drawStrum(arc, i - 2);\n      }).on('dragend', onDragEnd());\n      circles.enter().append('circle').attr('id', 'arc-' + id).attr('class', 'arc');\n      circles.attr('cx', function (d) {\n        return d[0];\n      }).attr('cy', function (d) {\n        return d[1];\n      }).attr('r', 5).style('opacity', function (d, i) {\n        return activePoint !== undefined && i === activePoint ? 0.8 : 0;\n      }).on('mouseover', function () {\n        d3.select(this).style('opacity', 0.8);\n      }).on('mouseout', function () {\n        d3.select(this).style('opacity', 0);\n      }).call(drag);\n    }\n\n    function dimensionsForPoint(p) {\n      var dims = {\n        i: -1,\n        left: undefined,\n        right: undefined\n      };\n\n      __.dimensions.some(function (dim, i) {\n        if (xscale(dim) < p[0]) {\n          var next = __.dimensions[i + 1];\n          dims.i = i;\n          dims.left = dim;\n          dims.right = next;\n          return false;\n        }\n\n        return true;\n      });\n\n      if (dims.left === undefined) {\n        // Event on the left side of the first axis.\n        dims.i = 0;\n        dims.left = __.dimensions[0];\n        dims.right = __.dimensions[1];\n      } else if (dims.right === undefined) {\n        // Event on the right side of the last axis\n        dims.i = __.dimensions.length - 1;\n        dims.right = dims.left;\n        dims.left = __.dimensions[__.dimensions.length - 2];\n      }\n\n      return dims;\n    }\n\n    function onDragStart() {\n      // First we need to determine between which two axes the arc was started.\n      // This will determine the freedom of movement, because a arc can\n      // logically only happen between two axes, so no movement outside these axes\n      // should be allowed.\n      return function () {\n        var p = d3.mouse(strumRect[0][0]),\n            dims,\n            arc;\n        p[0] = p[0] - __.margin.left;\n        p[1] = p[1] - __.margin.top;\n        dims = dimensionsForPoint(p), arc = {\n          p1: p,\n          dims: dims,\n          minX: xscale(dims.left),\n          maxX: xscale(dims.right),\n          minY: 0,\n          maxY: h(),\n          startAngle: undefined,\n          endAngle: undefined,\n          arc: d3.svg.arc().innerRadius(0)\n        };\n        arcs[dims.i] = arc;\n        arcs.active = dims.i; // Make sure that the point is within the bounds\n\n        arc.p1[0] = Math.min(Math.max(arc.minX, p[0]), arc.maxX);\n        arc.p2 = arc.p1.slice();\n        arc.p3 = arc.p1.slice();\n      };\n    }\n\n    function onDrag() {\n      return function () {\n        var ev = d3.event,\n            arc = arcs[arcs.active]; // Make sure that the point is within the bounds\n\n        arc.p2[0] = Math.min(Math.max(arc.minX + 1, ev.x - __.margin.left), arc.maxX);\n        arc.p2[1] = Math.min(Math.max(arc.minY, ev.y - __.margin.top), arc.maxY);\n        arc.p3 = arc.p2.slice();\n        drawStrum(arc, 1);\n      };\n    } // some helper functions\n\n\n    function hypothenuse(a, b) {\n      return Math.sqrt(a * a + b * b);\n    }\n\n    var rad = function () {\n      var c = Math.PI / 180;\n      return function (angle) {\n        return angle * c;\n      };\n    }();\n\n    var deg = function () {\n      var c = 180 / Math.PI;\n      return function (angle) {\n        return angle * c;\n      };\n    }(); // [0, 2*PI] -> [-PI/2, PI/2]\n\n\n    var signedAngle = function signedAngle(angle) {\n      var ret = angle;\n\n      if (angle > Math.PI) {\n        ret = angle - 1.5 * Math.PI;\n        ret = angle - 1.5 * Math.PI;\n      } else {\n        ret = angle - 0.5 * Math.PI;\n        ret = angle - 0.5 * Math.PI;\n      }\n\n      return -ret;\n    };\n    /**\n     * angles are stored in radians from in [0, 2*PI], where 0 in 12 o'clock.\n     * However, one can only select lines from 0 to PI, so we compute the\n     * 'signed' angle, where 0 is the horizontal line (3 o'clock), and +/- PI/2\n     * are 12 and 6 o'clock respectively.\n     */\n\n\n    function containmentTest(arc) {\n      var startAngle = signedAngle(arc.startAngle);\n      var endAngle = signedAngle(arc.endAngle);\n\n      if (startAngle > endAngle) {\n        var tmp = startAngle;\n        startAngle = endAngle;\n        endAngle = tmp;\n      } // test if segment angle is contained in angle interval\n\n\n      return function (a) {\n        if (a >= startAngle && a <= endAngle) {\n          return true;\n        }\n\n        return false;\n      };\n    }\n\n    function selected() {\n      var ids = Object.getOwnPropertyNames(arcs),\n          brushed = __.data; // Get the ids of the currently active arcs.\n\n      ids = ids.filter(function (d) {\n        return !isNaN(d);\n      });\n\n      function crossesStrum(d, id) {\n        var arc = arcs[id],\n            test = containmentTest(arc),\n            d1 = arc.dims.left,\n            d2 = arc.dims.right,\n            y1 = yscale[d1],\n            y2 = yscale[d2],\n            a = arcs.width(id),\n            b = y1(d[d1]) - y2(d[d2]),\n            c = hypothenuse(a, b),\n            angle = Math.asin(b / c); // rad in [-PI/2, PI/2]\n\n        return test(angle);\n      }\n\n      if (ids.length === 0) {\n        return brushed;\n      }\n\n      return brushed.filter(function (d) {\n        switch (brush.predicate) {\n          case 'AND':\n            return ids.every(function (id) {\n              return crossesStrum(d, id);\n            });\n\n          case 'OR':\n            return ids.some(function (id) {\n              return crossesStrum(d, id);\n            });\n\n          default:\n            throw 'Unknown brush predicate ' + __.brushPredicate;\n        }\n      });\n    }\n\n    function removeStrum() {\n      var arc = arcs[arcs.active],\n          svg = pc.selection.select('svg').select('g#arcs');\n      delete arcs[arcs.active];\n      arcs.active = undefined;\n      svg.selectAll('line#arc-' + arc.dims.i).remove();\n      svg.selectAll('circle#arc-' + arc.dims.i).remove();\n      svg.selectAll('path#arc-' + arc.dims.i).remove();\n    }\n\n    function onDragEnd() {\n      return function () {\n        var brushed = __.data,\n            arc = arcs[arcs.active]; // Okay, somewhat unexpected, but not totally unsurprising, a mousclick is\n        // considered a drag without move. So we have to deal with that case\n\n        if (arc && arc.p1[0] === arc.p2[0] && arc.p1[1] === arc.p2[1]) {\n          removeStrum(arcs);\n        }\n\n        if (arc) {\n          var angle = arcs.startAngle(arcs.active);\n          arc.startAngle = angle;\n          arc.endAngle = angle;\n          arc.arc.outerRadius(arcs.length(arcs.active)).startAngle(angle).endAngle(angle);\n        }\n\n        brushed = selected(arcs);\n        arcs.active = undefined;\n        __.brushed = brushed;\n        pc.renderBrushed();\n        events.brushend.call(pc, __.brushed);\n      };\n    }\n\n    function brushReset(arcs) {\n      return function () {\n        var ids = Object.getOwnPropertyNames(arcs).filter(function (d) {\n          return !isNaN(d);\n        });\n        ids.forEach(function (d) {\n          arcs.active = d;\n          removeStrum(arcs);\n        });\n        onDragEnd(arcs)();\n      };\n    }\n\n    function install() {\n      var drag = d3.behavior.drag(); // Map of current arcs. arcs are stored per segment of the PC. A segment,\n      // being the area between two axes. The left most area is indexed at 0.\n\n      arcs.active = undefined; // Returns the width of the PC segment where currently a arc is being\n      // placed. NOTE: even though they are evenly spaced in our current\n      // implementation, we keep for when non-even spaced segments are supported as\n      // well.\n\n      arcs.width = function (id) {\n        var arc = arcs[id];\n\n        if (arc === undefined) {\n          return undefined;\n        }\n\n        return arc.maxX - arc.minX;\n      }; // returns angles in [-PI/2, PI/2]\n\n\n      angle = function angle(p1, p2) {\n        var a = p1[0] - p2[0],\n            b = p1[1] - p2[1],\n            c = hypothenuse(a, b);\n        return Math.asin(b / c);\n      }; // returns angles in [0, 2 * PI]\n\n\n      arcs.endAngle = function (id) {\n        var arc = arcs[id];\n\n        if (arc === undefined) {\n          return undefined;\n        }\n\n        var sAngle = angle(arc.p1, arc.p2),\n            uAngle = -sAngle + Math.PI / 2;\n\n        if (arc.p1[0] > arc.p2[0]) {\n          uAngle = 2 * Math.PI - uAngle;\n        }\n\n        return uAngle;\n      };\n\n      arcs.startAngle = function (id) {\n        var arc = arcs[id];\n\n        if (arc === undefined) {\n          return undefined;\n        }\n\n        var sAngle = angle(arc.p1, arc.p3),\n            uAngle = -sAngle + Math.PI / 2;\n\n        if (arc.p1[0] > arc.p3[0]) {\n          uAngle = 2 * Math.PI - uAngle;\n        }\n\n        return uAngle;\n      };\n\n      arcs.length = function (id) {\n        var arc = arcs[id];\n\n        if (arc === undefined) {\n          return undefined;\n        }\n\n        var a = arc.p1[0] - arc.p2[0],\n            b = arc.p1[1] - arc.p2[1],\n            c = hypothenuse(a, b);\n        return c;\n      };\n\n      pc.on('axesreorder.arcs', function () {\n        var ids = Object.getOwnPropertyNames(arcs).filter(function (d) {\n          return !isNaN(d);\n        }); // Checks if the first dimension is directly left of the second dimension.\n\n        function consecutive(first, second) {\n          var length = __.dimensions.length;\n          return __.dimensions.some(function (d, i) {\n            return d === first ? i + i < length && __.dimensions[i + 1] === second : false;\n          });\n        }\n\n        if (ids.length > 0) {\n          // We have some arcs, which might need to be removed.\n          ids.forEach(function (d) {\n            var dims = arcs[d].dims;\n            arcs.active = d; // If the two dimensions of the current arc are not next to each other\n            // any more, than we'll need to remove the arc. Otherwise we keep it.\n\n            if (!consecutive(dims.left, dims.right)) {\n              removeStrum(arcs);\n            }\n          });\n          onDragEnd(arcs)();\n        }\n      }); // Add a new svg group in which we draw the arcs.\n\n      pc.selection.select('svg').append('g').attr('id', 'arcs').attr('transform', 'translate(' + __.margin.left + ',' + __.margin.top + ')'); // Install the required brushReset function\n\n      pc.brushReset = brushReset(arcs);\n      drag.on('dragstart', onDragStart(arcs)).on('drag', onDrag(arcs)).on('dragend', onDragEnd(arcs)); // NOTE: The styling needs to be done here and not in the css. This is because\n      //       for 1D brushing, the canvas layers should not listen to\n      //       pointer-events.\n\n      strumRect = pc.selection.select('svg').insert('rect', 'g#arcs').attr('id', 'arc-events').attr('x', __.margin.left).attr('y', __.margin.top).attr('width', w()).attr('height', h() + 2).style('opacity', 0).call(drag);\n    }\n\n    brush.modes['angular'] = {\n      install: install,\n      uninstall: function uninstall() {\n        pc.selection.select('svg').select('g#arcs').remove();\n        pc.selection.select('svg').select('rect#arc-events').remove();\n        pc.on('axesreorder.arcs', undefined);\n        delete pc.brushReset;\n        strumRect = undefined;\n      },\n      selected: selected,\n      brushState: function brushState() {\n        return arcs;\n      }\n    };\n  })();\n\n  pc.interactive = function () {\n    flags.interactive = true;\n    return this;\n  }; // expose a few objects\n\n\n  pc.xscale = xscale;\n  pc.yscale = yscale;\n  pc.ctx = ctx;\n  pc.canvas = canvas;\n\n  pc.g = function () {\n    return g;\n  }; // rescale for height, width and margins\n  // TODO currently assumes chart is brushable, and destroys old brushes\n\n\n  pc.resize = function () {\n    // selection size\n    pc.selection.select('svg').attr('width', __.width).attr('height', __.height);\n    pc.svg.attr('transform', 'translate(' + __.margin.left + ',' + __.margin.top + ')'); // FIXME: the current brush state should pass through\n\n    if (flags.brushable) pc.brushReset(); // scales\n\n    pc.autoscale(); // axes, destroys old brushes.\n\n    if (g) pc.createAxes();\n    if (flags.brushable) pc.brushable();\n    if (flags.reorderable) pc.reorderable();\n    events.resize.call(this, {\n      width: __.width,\n      height: __.height,\n      margin: __.margin\n    });\n    return this;\n  }; // highlight an array of data\n\n\n  pc.highlight = function (data) {\n    if (arguments.length === 0) {\n      return __.highlighted;\n    }\n\n    __.highlighted = data;\n    pc.clear('highlight');\n    d3.selectAll([canvas.foreground, canvas.brushed]).classed('faded', true);\n    data.forEach(path_highlight);\n    events.highlight.call(this, data);\n    return this;\n  }; // clear highlighting\n\n\n  pc.unhighlight = function () {\n    __.highlighted = [];\n    pc.clear('highlight');\n    d3.selectAll([canvas.foreground, canvas.brushed]).classed('faded', false);\n    return this;\n  }; // calculate 2d intersection of line a->b with line c->d\n  // points are objects with x and y properties\n\n\n  pc.intersection = function (a, b, c, d) {\n    return {\n      x: ((a.x * b.y - a.y * b.x) * (c.x - d.x) - (a.x - b.x) * (c.x * d.y - c.y * d.x)) / ((a.x - b.x) * (c.y - d.y) - (a.y - b.y) * (c.x - d.x)),\n      y: ((a.x * b.y - a.y * b.x) * (c.y - d.y) - (a.y - b.y) * (c.x * d.y - c.y * d.x)) / ((a.x - b.x) * (c.y - d.y) - (a.y - b.y) * (c.x - d.x))\n    };\n  };\n\n  function position(d) {\n    var v = dragging[d];\n    return v == null ? xscale(d) : v;\n  }\n\n  pc.version = '0.7.0'; // this descriptive text should live with other introspective methods\n\n  pc.toString = function () {\n    return 'Parallel Coordinates: ' + __.dimensions.length + ' dimensions (' + d3.keys(__.data[0]).length + ' total) , ' + __.data.length + ' rows';\n  };\n\n  return pc;\n});\n\nd3.renderQueue = function (func) {\n  var _queue = [],\n      // data to be rendered\n  _rate = 10,\n      // number of calls per frame\n  _clear = function _clear() {},\n      // clearing function\n  _i = 0; // current iteration\n\n\n  var rq = function rq(data) {\n    if (data) rq.data(data);\n    rq.invalidate();\n\n    _clear();\n\n    rq.render();\n  };\n\n  rq.render = function () {\n    _i = 0;\n    var valid = true;\n\n    rq.invalidate = function () {\n      valid = false;\n    };\n\n    function doFrame() {\n      if (!valid) return true;\n      if (_i > _queue.length) return true; // Typical d3 behavior is to pass a data item *and* its index. As the\n      // render queue splits the original data set, we'll have to be slightly\n      // more carefull about passing the correct index with the data item.\n\n      var end = Math.min(_i + _rate, _queue.length);\n\n      for (var i = _i; i < end; i++) {\n        func(_queue[i], i);\n      }\n\n      _i += _rate;\n    }\n\n    d3.timer(doFrame);\n  };\n\n  rq.data = function (data) {\n    rq.invalidate();\n    _queue = data.slice(0);\n    return rq;\n  };\n\n  rq.rate = function (value) {\n    if (!arguments.length) return _rate;\n    _rate = value;\n    return rq;\n  };\n\n  rq.remaining = function () {\n    return _queue.length - _i;\n  }; // clear the canvas\n\n\n  rq.clear = function (func) {\n    if (!arguments.length) {\n      _clear();\n\n      return rq;\n    }\n\n    _clear = func;\n    return rq;\n  };\n\n  rq.invalidate = function () {};\n\n  return rq;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHN1cGVyc2V0LXVpL2xlZ2FjeS1wbHVnaW4tY2hhcnQtcGFyYWxsZWwtY29vcmRpbmF0ZXMvZXNtL3ZlbmRvci9wYXJjb29yZHMvZDMucGFyY29vcmRzLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BzdXBlcnNldC11aS9sZWdhY3ktcGx1Z2luLWNoYXJ0LXBhcmFsbGVsLWNvb3JkaW5hdGVzL2VzbS92ZW5kb3IvcGFyY29vcmRzL2QzLnBhcmNvb3Jkcy5qcz8xNzJjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIFtMSUNFTlNFIFRCRF0gKi9cblxuLyogZXNsaW50LWRpc2FibGUgKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgdmFyIF9fID0ge1xuICAgIGRhdGE6IFtdLFxuICAgIGhpZ2hsaWdodGVkOiBbXSxcbiAgICBkaW1lbnNpb25zOiBbXSxcbiAgICBkaW1lbnNpb25UaXRsZXM6IHt9LFxuICAgIGRpbWVuc2lvblRpdGxlUm90YXRpb246IDAsXG4gICAgdHlwZXM6IHt9LFxuICAgIGJydXNoZWQ6IGZhbHNlLFxuICAgIGJydXNoZWRDb2xvcjogbnVsbCxcbiAgICBhbHBoYU9uQnJ1c2hlZDogMC4wLFxuICAgIG1vZGU6ICdkZWZhdWx0JyxcbiAgICByYXRlOiAyMCxcbiAgICB3aWR0aDogNjAwLFxuICAgIGhlaWdodDogMzAwLFxuICAgIG1hcmdpbjoge1xuICAgICAgdG9wOiAyNCxcbiAgICAgIHJpZ2h0OiAwLFxuICAgICAgYm90dG9tOiAxMixcbiAgICAgIGxlZnQ6IDBcbiAgICB9LFxuICAgIG51bGxWYWx1ZVNlcGFyYXRvcjogJ3VuZGVmaW5lZCcsXG4gICAgLy8gc2V0IHRvIFwidG9wXCIgb3IgXCJib3R0b21cIlxuICAgIG51bGxWYWx1ZVNlcGFyYXRvclBhZGRpbmc6IHtcbiAgICAgIHRvcDogOCxcbiAgICAgIHJpZ2h0OiAwLFxuICAgICAgYm90dG9tOiA4LFxuICAgICAgbGVmdDogMFxuICAgIH0sXG4gICAgY29sb3I6ICcjMDY5JyxcbiAgICBjb21wb3NpdGU6ICdzb3VyY2Utb3ZlcicsXG4gICAgYWxwaGE6IDAuNyxcbiAgICBidW5kbGluZ1N0cmVuZ3RoOiAwLjUsXG4gICAgYnVuZGxlRGltZW5zaW9uOiBudWxsLFxuICAgIHNtb290aG5lc3M6IDAuMCxcbiAgICBzaG93Q29udHJvbFBvaW50czogZmFsc2UsXG4gICAgaGlkZUF4aXM6IFtdXG4gIH07XG4gIGV4dGVuZChfXywgY29uZmlnKTtcblxuICB2YXIgcGMgPSBmdW5jdGlvbiBwYyhzZWxlY3Rpb24pIHtcbiAgICBzZWxlY3Rpb24gPSBwYy5zZWxlY3Rpb24gPSBkMy5zZWxlY3Qoc2VsZWN0aW9uKTtcbiAgICBfXy53aWR0aCA9IHNlbGVjdGlvblswXVswXS5jbGllbnRXaWR0aDtcbiAgICBfXy5oZWlnaHQgPSBzZWxlY3Rpb25bMF1bMF0uY2xpZW50SGVpZ2h0OyAvLyBjYW52YXMgZGF0YSBsYXllcnNcblxuICAgIFsnbWFya3MnLCAnZm9yZWdyb3VuZCcsICdicnVzaGVkJywgJ2hpZ2hsaWdodCddLmZvckVhY2goZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgICBjYW52YXNbbGF5ZXJdID0gc2VsZWN0aW9uLmFwcGVuZCgnY2FudmFzJykuYXR0cignY2xhc3MnLCBsYXllcilbMF1bMF07XG4gICAgICBjdHhbbGF5ZXJdID0gY2FudmFzW2xheWVyXS5nZXRDb250ZXh0KCcyZCcpO1xuICAgIH0pOyAvLyBzdmcgdGljayBhbmQgYnJ1c2ggbGF5ZXJzXG5cbiAgICBwYy5zdmcgPSBzZWxlY3Rpb24uYXBwZW5kKCdzdmcnKS5hdHRyKCd3aWR0aCcsIF9fLndpZHRoKS5hdHRyKCdoZWlnaHQnLCBfXy5oZWlnaHQpLmFwcGVuZCgnc3ZnOmcnKS5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyBfXy5tYXJnaW4ubGVmdCArICcsJyArIF9fLm1hcmdpbi50b3AgKyAnKScpO1xuICAgIHJldHVybiBwYztcbiAgfTtcblxuICB2YXIgZXZlbnRzID0gZDMuZGlzcGF0Y2guYXBwbHkodGhpcywgWydyZW5kZXInLCAncmVzaXplJywgJ2hpZ2hsaWdodCcsICdicnVzaCcsICdicnVzaGVuZCcsICdheGVzcmVvcmRlciddLmNvbmNhdChkMy5rZXlzKF9fKSkpLFxuICAgICAgdyA9IGZ1bmN0aW9uIHcoKSB7XG4gICAgcmV0dXJuIF9fLndpZHRoIC0gX18ubWFyZ2luLnJpZ2h0IC0gX18ubWFyZ2luLmxlZnQ7XG4gIH0sXG4gICAgICBoID0gZnVuY3Rpb24gaCgpIHtcbiAgICByZXR1cm4gX18uaGVpZ2h0IC0gX18ubWFyZ2luLnRvcCAtIF9fLm1hcmdpbi5ib3R0b207XG4gIH0sXG4gICAgICBmbGFncyA9IHtcbiAgICBicnVzaGFibGU6IGZhbHNlLFxuICAgIHJlb3JkZXJhYmxlOiBmYWxzZSxcbiAgICBheGVzOiBmYWxzZSxcbiAgICBpbnRlcmFjdGl2ZTogZmFsc2UsXG4gICAgZGVidWc6IGZhbHNlXG4gIH0sXG4gICAgICB4c2NhbGUgPSBkMy5zY2FsZS5vcmRpbmFsKCksXG4gICAgICB5c2NhbGUgPSB7fSxcbiAgICAgIGRyYWdnaW5nID0ge30sXG4gICAgICBsaW5lID0gZDMuc3ZnLmxpbmUoKSxcbiAgICAgIGF4aXMgPSBkMy5zdmcuYXhpcygpLm9yaWVudCgnbGVmdCcpLnRpY2tzKDUpLFxuICAgICAgZyxcbiAgICAgIC8vIGdyb3VwcyBmb3IgYXhlcywgYnJ1c2hlc1xuICBjdHggPSB7fSxcbiAgICAgIGNhbnZhcyA9IHt9LFxuICAgICAgY2x1c3RlckNlbnRyb2lkcyA9IFtdOyAvLyBzaWRlIGVmZmVjdHMgZm9yIHNldHRlcnNcblxuXG4gIHZhciBzaWRlX2VmZmVjdHMgPSBkMy5kaXNwYXRjaC5hcHBseSh0aGlzLCBkMy5rZXlzKF9fKSkub24oJ2NvbXBvc2l0ZScsIGZ1bmN0aW9uIChkKSB7XG4gICAgY3R4LmZvcmVncm91bmQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gZC52YWx1ZTtcbiAgICBjdHguYnJ1c2hlZC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBkLnZhbHVlO1xuICB9KS5vbignYWxwaGEnLCBmdW5jdGlvbiAoZCkge1xuICAgIGN0eC5mb3JlZ3JvdW5kLmdsb2JhbEFscGhhID0gZC52YWx1ZTtcbiAgICBjdHguYnJ1c2hlZC5nbG9iYWxBbHBoYSA9IGQudmFsdWU7XG4gIH0pLm9uKCdicnVzaGVkQ29sb3InLCBmdW5jdGlvbiAoZCkge1xuICAgIGN0eC5icnVzaGVkLnN0cm9rZVN0eWxlID0gZC52YWx1ZTtcbiAgfSkub24oJ3dpZHRoJywgZnVuY3Rpb24gKGQpIHtcbiAgICBwYy5yZXNpemUoKTtcbiAgfSkub24oJ2hlaWdodCcsIGZ1bmN0aW9uIChkKSB7XG4gICAgcGMucmVzaXplKCk7XG4gIH0pLm9uKCdtYXJnaW4nLCBmdW5jdGlvbiAoZCkge1xuICAgIHBjLnJlc2l6ZSgpO1xuICB9KS5vbigncmF0ZScsIGZ1bmN0aW9uIChkKSB7XG4gICAgYnJ1c2hlZFF1ZXVlLnJhdGUoZC52YWx1ZSk7XG4gICAgZm9yZWdyb3VuZFF1ZXVlLnJhdGUoZC52YWx1ZSk7XG4gIH0pLm9uKCdkaW1lbnNpb25zJywgZnVuY3Rpb24gKGQpIHtcbiAgICB4c2NhbGUuZG9tYWluKF9fLmRpbWVuc2lvbnMpO1xuXG4gICAgaWYgKGZsYWdzLmludGVyYWN0aXZlKSB7XG4gICAgICBwYy5yZW5kZXIoKS51cGRhdGVBeGVzKCk7XG4gICAgfVxuICB9KS5vbignYnVuZGxlRGltZW5zaW9uJywgZnVuY3Rpb24gKGQpIHtcbiAgICBpZiAoIV9fLmRpbWVuc2lvbnMubGVuZ3RoKSBwYy5kZXRlY3REaW1lbnNpb25zKCk7XG4gICAgaWYgKCEoX18uZGltZW5zaW9uc1swXSBpbiB5c2NhbGUpKSBwYy5hdXRvc2NhbGUoKTtcblxuICAgIGlmICh0eXBlb2YgZC52YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIGlmIChkLnZhbHVlIDwgX18uZGltZW5zaW9ucy5sZW5ndGgpIHtcbiAgICAgICAgX18uYnVuZGxlRGltZW5zaW9uID0gX18uZGltZW5zaW9uc1tkLnZhbHVlXTtcbiAgICAgIH0gZWxzZSBpZiAoZC52YWx1ZSA8IF9fLmhpZGVBeGlzLmxlbmd0aCkge1xuICAgICAgICBfXy5idW5kbGVEaW1lbnNpb24gPSBfXy5oaWRlQXhpc1tkLnZhbHVlXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgX18uYnVuZGxlRGltZW5zaW9uID0gZC52YWx1ZTtcbiAgICB9XG5cbiAgICBfXy5jbHVzdGVyQ2VudHJvaWRzID0gY29tcHV0ZV9jbHVzdGVyX2NlbnRyb2lkcyhfXy5idW5kbGVEaW1lbnNpb24pO1xuICB9KS5vbignaGlkZUF4aXMnLCBmdW5jdGlvbiAoZCkge1xuICAgIGlmICghX18uZGltZW5zaW9ucy5sZW5ndGgpIHBjLmRldGVjdERpbWVuc2lvbnMoKTtcbiAgICBwYy5kaW1lbnNpb25zKHdpdGhvdXQoX18uZGltZW5zaW9ucywgZC52YWx1ZSkpO1xuICB9KTsgLy8gZXhwb3NlIHRoZSBzdGF0ZSBvZiB0aGUgY2hhcnRcblxuICBwYy5zdGF0ZSA9IF9fO1xuICBwYy5mbGFncyA9IGZsYWdzOyAvLyBjcmVhdGUgZ2V0dGVyL3NldHRlcnNcblxuICBnZXRzZXQocGMsIF9fLCBldmVudHMpOyAvLyBleHBvc2UgZXZlbnRzXG5cbiAgZDMucmViaW5kKHBjLCBldmVudHMsICdvbicpOyAvLyBnZXR0ZXIvc2V0dGVyIHdpdGggZXZlbnQgZmlyaW5nXG5cbiAgZnVuY3Rpb24gZ2V0c2V0KG9iaiwgc3RhdGUsIGV2ZW50cykge1xuICAgIGQzLmtleXMoc3RhdGUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgb2JqW2tleV0gPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gc3RhdGVba2V5XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBvbGQgPSBzdGF0ZVtrZXldO1xuICAgICAgICBzdGF0ZVtrZXldID0geDtcbiAgICAgICAgc2lkZV9lZmZlY3RzW2tleV0uY2FsbChwYywge1xuICAgICAgICAgIHZhbHVlOiB4LFxuICAgICAgICAgIHByZXZpb3VzOiBvbGRcbiAgICAgICAgfSk7XG4gICAgICAgIGV2ZW50c1trZXldLmNhbGwocGMsIHtcbiAgICAgICAgICB2YWx1ZTogeCxcbiAgICAgICAgICBwcmV2aW91czogb2xkXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGV4dGVuZCh0YXJnZXQsIHNvdXJjZSkge1xuICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdpdGhvdXQoYXJyLCBpdGVtKSB7XG4gICAgcmV0dXJuIGFyci5maWx0ZXIoZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgIHJldHVybiBpdGVtLmluZGV4T2YoZWxlbSkgPT09IC0xO1xuICAgIH0pO1xuICB9XG4gIC8qKiBhZGp1c3RzIGFuIGF4aXMnIGRlZmF1bHQgcmFuZ2UgW2goKSsxLCAxXSBpZiBhIE51bGxWYWx1ZVNlcGFyYXRvciBpcyBzZXQgKi9cblxuXG4gIGZ1bmN0aW9uIGdldFJhbmdlKCkge1xuICAgIGlmIChfXy5udWxsVmFsdWVTZXBhcmF0b3IgPT0gJ2JvdHRvbScpIHtcbiAgICAgIHJldHVybiBbaCgpICsgMSAtIF9fLm51bGxWYWx1ZVNlcGFyYXRvclBhZGRpbmcuYm90dG9tIC0gX18ubnVsbFZhbHVlU2VwYXJhdG9yUGFkZGluZy50b3AsIDFdO1xuICAgIH0gZWxzZSBpZiAoX18ubnVsbFZhbHVlU2VwYXJhdG9yID09ICd0b3AnKSB7XG4gICAgICByZXR1cm4gW2goKSArIDEsIDEgKyBfXy5udWxsVmFsdWVTZXBhcmF0b3JQYWRkaW5nLmJvdHRvbSArIF9fLm51bGxWYWx1ZVNlcGFyYXRvclBhZGRpbmcudG9wXTtcbiAgICB9XG5cbiAgICByZXR1cm4gW2goKSArIDEsIDFdO1xuICB9XG5cbiAgcGMuYXV0b3NjYWxlID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIHlzY2FsZVxuICAgIHZhciBkZWZhdWx0U2NhbGVzID0ge1xuICAgICAgZGF0ZTogZnVuY3Rpb24gZGF0ZShrKSB7XG4gICAgICAgIHZhciBleHRlbnQgPSBkMy5leHRlbnQoX18uZGF0YSwgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICByZXR1cm4gZFtrXSA/IGRba10uZ2V0VGltZSgpIDogbnVsbDtcbiAgICAgICAgfSk7IC8vIHNwZWNpYWwgY2FzZSBpZiBzaW5nbGUgdmFsdWVcblxuICAgICAgICBpZiAoZXh0ZW50WzBdID09PSBleHRlbnRbMV0pIHtcbiAgICAgICAgICByZXR1cm4gZDMuc2NhbGUub3JkaW5hbCgpLmRvbWFpbihbZXh0ZW50WzBdXSkucmFuZ2VQb2ludHMoZ2V0UmFuZ2UoKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZDMudGltZS5zY2FsZSgpLmRvbWFpbihleHRlbnQpLnJhbmdlKGdldFJhbmdlKCkpO1xuICAgICAgfSxcbiAgICAgIG51bWJlcjogZnVuY3Rpb24gbnVtYmVyKGspIHtcbiAgICAgICAgdmFyIGV4dGVudCA9IGQzLmV4dGVudChfXy5kYXRhLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgIHJldHVybiArZFtrXTtcbiAgICAgICAgfSk7IC8vIHNwZWNpYWwgY2FzZSBpZiBzaW5nbGUgdmFsdWVcblxuICAgICAgICBpZiAoZXh0ZW50WzBdID09PSBleHRlbnRbMV0pIHtcbiAgICAgICAgICByZXR1cm4gZDMuc2NhbGUub3JkaW5hbCgpLmRvbWFpbihbZXh0ZW50WzBdXSkucmFuZ2VQb2ludHMoZ2V0UmFuZ2UoKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZDMuc2NhbGUubGluZWFyKCkuZG9tYWluKGV4dGVudCkucmFuZ2UoZ2V0UmFuZ2UoKSk7XG4gICAgICB9LFxuICAgICAgc3RyaW5nOiBmdW5jdGlvbiBzdHJpbmcoaykge1xuICAgICAgICB2YXIgY291bnRzID0ge30sXG4gICAgICAgICAgICBkb21haW4gPSBbXTsgLy8gTGV0J3MgZ2V0IHRoZSBjb3VudCBmb3IgZWFjaCB2YWx1ZSBzbyB0aGF0IHdlIGNhbiBzb3J0IHRoZSBkb21haW4gYmFzZWRcbiAgICAgICAgLy8gb24gdGhlIG51bWJlciBvZiBpdGVtcyBmb3IgZWFjaCB2YWx1ZS5cblxuICAgICAgICBfXy5kYXRhLm1hcChmdW5jdGlvbiAocCkge1xuICAgICAgICAgIGlmIChwW2tdID09PSB1bmRlZmluZWQgJiYgX18ubnVsbFZhbHVlU2VwYXJhdG9yICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuOyAvLyBudWxsIHZhbHVlcyB3aWxsIGJlIGRyYXduIGJleW9uZCB0aGUgaG9yaXpvbnRhbCBudWxsIHZhbHVlIHNlcGFyYXRvciFcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoY291bnRzW3Bba11dID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvdW50c1twW2tdXSA9IDE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvdW50c1twW2tdXSA9IGNvdW50c1twW2tdXSArIDE7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBkb21haW4gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhjb3VudHMpLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICByZXR1cm4gY291bnRzW2FdIC0gY291bnRzW2JdO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGQzLnNjYWxlLm9yZGluYWwoKS5kb21haW4oZG9tYWluKS5yYW5nZVBvaW50cyhnZXRSYW5nZSgpKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX18uZGltZW5zaW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICB5c2NhbGVba10gPSBkZWZhdWx0U2NhbGVzW19fLnR5cGVzW2tdXShrKTtcbiAgICB9KTtcblxuICAgIF9fLmhpZGVBeGlzLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgIHlzY2FsZVtrXSA9IGRlZmF1bHRTY2FsZXNbX18udHlwZXNba11dKGspO1xuICAgIH0pOyAvLyB4c2NhbGVcblxuXG4gICAgeHNjYWxlLnJhbmdlUG9pbnRzKFswLCB3KCldLCAxKTsgLy8gY2FudmFzIHNpemVzXG5cbiAgICBwYy5zZWxlY3Rpb24uc2VsZWN0QWxsKCdjYW52YXMnKS5zdHlsZSgnbWFyZ2luLXRvcCcsIF9fLm1hcmdpbi50b3AgKyAncHgnKS5zdHlsZSgnbWFyZ2luLWxlZnQnLCBfXy5tYXJnaW4ubGVmdCArICdweCcpLmF0dHIoJ3dpZHRoJywgdygpICsgMikuYXR0cignaGVpZ2h0JywgaCgpICsgMik7IC8vIGRlZmF1bHQgc3R5bGVzLCBuZWVkcyB0byBiZSBzZXQgd2hlbiBjYW52YXMgd2lkdGggY2hhbmdlc1xuXG4gICAgY3R4LmZvcmVncm91bmQuc3Ryb2tlU3R5bGUgPSBfXy5jb2xvcjtcbiAgICBjdHguZm9yZWdyb3VuZC5saW5lV2lkdGggPSAxLjQ7XG4gICAgY3R4LmZvcmVncm91bmQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gX18uY29tcG9zaXRlO1xuICAgIGN0eC5mb3JlZ3JvdW5kLmdsb2JhbEFscGhhID0gX18uYWxwaGE7XG4gICAgY3R4LmJydXNoZWQuc3Ryb2tlU3R5bGUgPSBfXy5icnVzaGVkQ29sb3I7XG4gICAgY3R4LmJydXNoZWQubGluZVdpZHRoID0gMS40O1xuICAgIGN0eC5icnVzaGVkLmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IF9fLmNvbXBvc2l0ZTtcbiAgICBjdHguYnJ1c2hlZC5nbG9iYWxBbHBoYSA9IF9fLmFscGhhO1xuICAgIGN0eC5oaWdobGlnaHQubGluZVdpZHRoID0gMztcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBwYy5zY2FsZSA9IGZ1bmN0aW9uIChkLCBkb21haW4pIHtcbiAgICB5c2NhbGVbZF0uZG9tYWluKGRvbWFpbik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgcGMuZmxpcCA9IGZ1bmN0aW9uIChkKSB7XG4gICAgLy95c2NhbGVbZF0uZG9tYWluKCkucmV2ZXJzZSgpOyAgICAgICAgIC8vIGRvZXMgbm90IHdvcmtcbiAgICB5c2NhbGVbZF0uZG9tYWluKHlzY2FsZVtkXS5kb21haW4oKS5yZXZlcnNlKCkpOyAvLyB3b3Jrc1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgcGMuY29tbW9uU2NhbGUgPSBmdW5jdGlvbiAoZ2xvYmFsLCB0eXBlKSB7XG4gICAgdmFyIHQgPSB0eXBlIHx8ICdudW1iZXInO1xuXG4gICAgaWYgKHR5cGVvZiBnbG9iYWwgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBnbG9iYWwgPSB0cnVlO1xuICAgIH0gLy8gc2NhbGVzIG9mIHRoZSBzYW1lIHR5cGVcblxuXG4gICAgdmFyIHNjYWxlcyA9IF9fLmRpbWVuc2lvbnMuY29uY2F0KF9fLmhpZGVBeGlzKS5maWx0ZXIoZnVuY3Rpb24gKHApIHtcbiAgICAgIHJldHVybiBfXy50eXBlc1twXSA9PSB0O1xuICAgIH0pO1xuXG4gICAgaWYgKGdsb2JhbCkge1xuICAgICAgdmFyIGV4dGVudCA9IGQzLmV4dGVudChzY2FsZXMubWFwKGZ1bmN0aW9uIChwLCBpKSB7XG4gICAgICAgIHJldHVybiB5c2NhbGVbcF0uZG9tYWluKCk7XG4gICAgICB9KS5yZWR1Y2UoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEuY29uY2F0KGIpO1xuICAgICAgfSkpO1xuICAgICAgc2NhbGVzLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgeXNjYWxlW2RdLmRvbWFpbihleHRlbnQpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNjYWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIHlzY2FsZVtrXS5kb21haW4oZDMuZXh0ZW50KF9fLmRhdGEsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgcmV0dXJuICtkW2tdO1xuICAgICAgICB9KSk7XG4gICAgICB9KTtcbiAgICB9IC8vIHVwZGF0ZSBjZW50cm9pZHNcblxuXG4gICAgaWYgKF9fLmJ1bmRsZURpbWVuc2lvbiAhPT0gbnVsbCkge1xuICAgICAgcGMuYnVuZGxlRGltZW5zaW9uKF9fLmJ1bmRsZURpbWVuc2lvbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgcGMuZGV0ZWN0RGltZW5zaW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICBwYy50eXBlcyhwYy5kZXRlY3REaW1lbnNpb25UeXBlcyhfXy5kYXRhKSk7XG4gICAgcGMuZGltZW5zaW9ucyhkMy5rZXlzKHBjLnR5cGVzKCkpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTsgLy8gYSBiZXR0ZXIgXCJ0eXBlb2ZcIiBmcm9tIHRoaXMgcG9zdDogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy83MzkwNDI2L2JldHRlci13YXktdG8tZ2V0LXR5cGUtb2YtYS1qYXZhc2NyaXB0LXZhcmlhYmxlXG5cblxuICBwYy50b1R5cGUgPSBmdW5jdGlvbiAodikge1xuICAgIHJldHVybiB7fS50b1N0cmluZy5jYWxsKHYpLm1hdGNoKC9cXHMoW2EtekEtWl0rKS8pWzFdLnRvTG93ZXJDYXNlKCk7XG4gIH07IC8vIHRyeSB0byBjb2VyY2UgdG8gbnVtYmVyIGJlZm9yZSByZXR1cm5pbmcgdHlwZVxuXG5cbiAgcGMudG9UeXBlQ29lcmNlTnVtYmVycyA9IGZ1bmN0aW9uICh2KSB7XG4gICAgaWYgKHBhcnNlRmxvYXQodikgPT0gdiAmJiB2ICE9IG51bGwpIHtcbiAgICAgIHJldHVybiAnbnVtYmVyJztcbiAgICB9XG5cbiAgICByZXR1cm4gcGMudG9UeXBlKHYpO1xuICB9OyAvLyBhdHRlbXB0IHRvIGRldGVybWluZSB0eXBlcyBvZiBlYWNoIGRpbWVuc2lvbiBiYXNlZCBvbiBmaXJzdCByb3cgb2YgZGF0YVxuXG5cbiAgcGMuZGV0ZWN0RGltZW5zaW9uVHlwZXMgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciB0eXBlcyA9IHt9O1xuICAgIGQzLmtleXMoZGF0YVswXSkuZm9yRWFjaChmdW5jdGlvbiAoY29sKSB7XG4gICAgICB0eXBlc1tjb2xdID0gcGMudG9UeXBlQ29lcmNlTnVtYmVycyhkYXRhWzBdW2NvbF0pO1xuICAgIH0pO1xuICAgIHJldHVybiB0eXBlcztcbiAgfTtcblxuICBwYy5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gdHJ5IHRvIGF1dG9kZXRlY3QgZGltZW5zaW9ucyBhbmQgY3JlYXRlIHNjYWxlc1xuICAgIGlmICghX18uZGltZW5zaW9ucy5sZW5ndGgpIHBjLmRldGVjdERpbWVuc2lvbnMoKTtcbiAgICBpZiAoIShfXy5kaW1lbnNpb25zWzBdIGluIHlzY2FsZSkpIHBjLmF1dG9zY2FsZSgpO1xuXG4gICAgcGMucmVuZGVyW19fLm1vZGVdKCk7XG5cbiAgICBldmVudHMucmVuZGVyLmNhbGwodGhpcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgcGMucmVuZGVyQnJ1c2hlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIV9fLmRpbWVuc2lvbnMubGVuZ3RoKSBwYy5kZXRlY3REaW1lbnNpb25zKCk7XG4gICAgaWYgKCEoX18uZGltZW5zaW9uc1swXSBpbiB5c2NhbGUpKSBwYy5hdXRvc2NhbGUoKTtcblxuICAgIHBjLnJlbmRlckJydXNoZWRbX18ubW9kZV0oKTtcblxuICAgIGV2ZW50cy5yZW5kZXIuY2FsbCh0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBmdW5jdGlvbiBpc0JydXNoZWQoKSB7XG4gICAgaWYgKF9fLmJydXNoZWQgJiYgX18uYnJ1c2hlZC5sZW5ndGggIT09IF9fLmRhdGEubGVuZ3RoKSByZXR1cm4gdHJ1ZTtcbiAgICB2YXIgb2JqZWN0ID0gYnJ1c2guY3VycmVudE1vZGUoKS5icnVzaFN0YXRlKCk7XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICBpZiAob2JqZWN0Lmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcGMucmVuZGVyLmRlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcGMuY2xlYXIoJ2ZvcmVncm91bmQnKTtcbiAgICBwYy5jbGVhcignaGlnaGxpZ2h0Jyk7XG4gICAgcGMucmVuZGVyQnJ1c2hlZC5kZWZhdWx0KCk7XG5cbiAgICBfXy5kYXRhLmZvckVhY2gocGF0aF9mb3JlZ3JvdW5kKTtcbiAgfTtcblxuICB2YXIgZm9yZWdyb3VuZFF1ZXVlID0gZDMucmVuZGVyUXVldWUocGF0aF9mb3JlZ3JvdW5kKS5yYXRlKDUwKS5jbGVhcihmdW5jdGlvbiAoKSB7XG4gICAgcGMuY2xlYXIoJ2ZvcmVncm91bmQnKTtcbiAgICBwYy5jbGVhcignaGlnaGxpZ2h0Jyk7XG4gIH0pO1xuXG4gIHBjLnJlbmRlci5xdWV1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBwYy5yZW5kZXJCcnVzaGVkLnF1ZXVlKCk7XG4gICAgZm9yZWdyb3VuZFF1ZXVlKF9fLmRhdGEpO1xuICB9O1xuXG4gIHBjLnJlbmRlckJydXNoZWQuZGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICBwYy5jbGVhcignYnJ1c2hlZCcpO1xuXG4gICAgaWYgKGlzQnJ1c2hlZCgpKSB7XG4gICAgICBfXy5icnVzaGVkLmZvckVhY2gocGF0aF9icnVzaGVkKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGJydXNoZWRRdWV1ZSA9IGQzLnJlbmRlclF1ZXVlKHBhdGhfYnJ1c2hlZCkucmF0ZSg1MCkuY2xlYXIoZnVuY3Rpb24gKCkge1xuICAgIHBjLmNsZWFyKCdicnVzaGVkJyk7XG4gIH0pO1xuXG4gIHBjLnJlbmRlckJydXNoZWQucXVldWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGlzQnJ1c2hlZCgpKSB7XG4gICAgICBicnVzaGVkUXVldWUoX18uYnJ1c2hlZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJydXNoZWRRdWV1ZShbXSk7IC8vIFRoaXMgaXMgbmVlZGVkIHRvIGNsZWFyIHRoZSBjdXJyZW50bHkgYnJ1c2hlZCBpdGVtc1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBjb21wdXRlX2NsdXN0ZXJfY2VudHJvaWRzKGQpIHtcbiAgICB2YXIgY2x1c3RlckNlbnRyb2lkcyA9IGQzLm1hcCgpO1xuICAgIHZhciBjbHVzdGVyQ291bnRzID0gZDMubWFwKCk7IC8vIGRldGVybWluZSBjbHVzdGVyQ291bnRzXG5cbiAgICBfXy5kYXRhLmZvckVhY2goZnVuY3Rpb24gKHJvdykge1xuICAgICAgdmFyIHNjYWxlZCA9IHlzY2FsZVtkXShyb3dbZF0pO1xuXG4gICAgICBpZiAoIWNsdXN0ZXJDb3VudHMuaGFzKHNjYWxlZCkpIHtcbiAgICAgICAgY2x1c3RlckNvdW50cy5zZXQoc2NhbGVkLCAwKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvdW50ID0gY2x1c3RlckNvdW50cy5nZXQoc2NhbGVkKTtcbiAgICAgIGNsdXN0ZXJDb3VudHMuc2V0KHNjYWxlZCwgY291bnQgKyAxKTtcbiAgICB9KTtcblxuICAgIF9fLmRhdGEuZm9yRWFjaChmdW5jdGlvbiAocm93KSB7XG4gICAgICBfXy5kaW1lbnNpb25zLm1hcChmdW5jdGlvbiAocCwgaSkge1xuICAgICAgICB2YXIgc2NhbGVkID0geXNjYWxlW2RdKHJvd1tkXSk7XG5cbiAgICAgICAgaWYgKCFjbHVzdGVyQ2VudHJvaWRzLmhhcyhzY2FsZWQpKSB7XG4gICAgICAgICAgdmFyIG1hcCA9IGQzLm1hcCgpO1xuICAgICAgICAgIGNsdXN0ZXJDZW50cm9pZHMuc2V0KHNjYWxlZCwgbWFwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghY2x1c3RlckNlbnRyb2lkcy5nZXQoc2NhbGVkKS5oYXMocCkpIHtcbiAgICAgICAgICBjbHVzdGVyQ2VudHJvaWRzLmdldChzY2FsZWQpLnNldChwLCAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB2YWx1ZSA9IGNsdXN0ZXJDZW50cm9pZHMuZ2V0KHNjYWxlZCkuZ2V0KHApO1xuICAgICAgICB2YWx1ZSArPSB5c2NhbGVbcF0ocm93W3BdKSAvIGNsdXN0ZXJDb3VudHMuZ2V0KHNjYWxlZCk7XG4gICAgICAgIGNsdXN0ZXJDZW50cm9pZHMuZ2V0KHNjYWxlZCkuc2V0KHAsIHZhbHVlKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGNsdXN0ZXJDZW50cm9pZHM7XG4gIH1cblxuICBmdW5jdGlvbiBjb21wdXRlX2NlbnRyb2lkcyhyb3cpIHtcbiAgICB2YXIgY2VudHJvaWRzID0gW107XG4gICAgdmFyIHAgPSBfXy5kaW1lbnNpb25zO1xuICAgIHZhciBjb2xzID0gcC5sZW5ndGg7XG4gICAgdmFyIGEgPSAwLjU7IC8vIGNlbnRlciBiZXR3ZWVuIGF4ZXNcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29sczsgKytpKSB7XG4gICAgICAvLyBjZW50cm9pZHMgb24gJ3JlYWwnIGF4ZXNcbiAgICAgIHZhciB4ID0gcG9zaXRpb24ocFtpXSk7XG4gICAgICB2YXIgeSA9IHlzY2FsZVtwW2ldXShyb3dbcFtpXV0pO1xuICAgICAgY2VudHJvaWRzLnB1c2goJFYoW3gsIHldKSk7IC8vIGNlbnRyb2lkcyBvbiAndmlydHVhbCcgYXhlc1xuXG4gICAgICBpZiAoaSA8IGNvbHMgLSAxKSB7XG4gICAgICAgIHZhciBjeCA9IHggKyBhICogKHBvc2l0aW9uKHBbaSArIDFdKSAtIHgpO1xuICAgICAgICB2YXIgY3kgPSB5ICsgYSAqICh5c2NhbGVbcFtpICsgMV1dKHJvd1twW2kgKyAxXV0pIC0geSk7XG5cbiAgICAgICAgaWYgKF9fLmJ1bmRsZURpbWVuc2lvbiAhPT0gbnVsbCkge1xuICAgICAgICAgIHZhciBsZWZ0Q2VudHJvaWQgPSBfXy5jbHVzdGVyQ2VudHJvaWRzLmdldCh5c2NhbGVbX18uYnVuZGxlRGltZW5zaW9uXShyb3dbX18uYnVuZGxlRGltZW5zaW9uXSkpLmdldChwW2ldKTtcblxuICAgICAgICAgIHZhciByaWdodENlbnRyb2lkID0gX18uY2x1c3RlckNlbnRyb2lkcy5nZXQoeXNjYWxlW19fLmJ1bmRsZURpbWVuc2lvbl0ocm93W19fLmJ1bmRsZURpbWVuc2lvbl0pKS5nZXQocFtpICsgMV0pO1xuXG4gICAgICAgICAgdmFyIGNlbnRyb2lkID0gMC41ICogKGxlZnRDZW50cm9pZCArIHJpZ2h0Q2VudHJvaWQpO1xuICAgICAgICAgIGN5ID0gY2VudHJvaWQgKyAoMSAtIF9fLmJ1bmRsaW5nU3RyZW5ndGgpICogKGN5IC0gY2VudHJvaWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2VudHJvaWRzLnB1c2goJFYoW2N4LCBjeV0pKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY2VudHJvaWRzO1xuICB9XG5cbiAgZnVuY3Rpb24gY29tcHV0ZV9jb250cm9sX3BvaW50cyhjZW50cm9pZHMpIHtcbiAgICB2YXIgY29scyA9IGNlbnRyb2lkcy5sZW5ndGg7XG4gICAgdmFyIGEgPSBfXy5zbW9vdGhuZXNzO1xuICAgIHZhciBjcHMgPSBbXTtcbiAgICBjcHMucHVzaChjZW50cm9pZHNbMF0pO1xuICAgIGNwcy5wdXNoKCRWKFtjZW50cm9pZHNbMF0uZSgxKSArIGEgKiAyICogKGNlbnRyb2lkc1sxXS5lKDEpIC0gY2VudHJvaWRzWzBdLmUoMSkpLCBjZW50cm9pZHNbMF0uZSgyKV0pKTtcblxuICAgIGZvciAodmFyIGNvbCA9IDE7IGNvbCA8IGNvbHMgLSAxOyArK2NvbCkge1xuICAgICAgdmFyIG1pZCA9IGNlbnRyb2lkc1tjb2xdO1xuICAgICAgdmFyIGxlZnQgPSBjZW50cm9pZHNbY29sIC0gMV07XG4gICAgICB2YXIgcmlnaHQgPSBjZW50cm9pZHNbY29sICsgMV07XG4gICAgICB2YXIgZGlmZiA9IGxlZnQuc3VidHJhY3QocmlnaHQpO1xuICAgICAgY3BzLnB1c2gobWlkLmFkZChkaWZmLngoYSkpKTtcbiAgICAgIGNwcy5wdXNoKG1pZCk7XG4gICAgICBjcHMucHVzaChtaWQuc3VidHJhY3QoZGlmZi54KGEpKSk7XG4gICAgfVxuXG4gICAgY3BzLnB1c2goJFYoW2NlbnRyb2lkc1tjb2xzIC0gMV0uZSgxKSArIGEgKiAyICogKGNlbnRyb2lkc1tjb2xzIC0gMl0uZSgxKSAtIGNlbnRyb2lkc1tjb2xzIC0gMV0uZSgxKSksIGNlbnRyb2lkc1tjb2xzIC0gMV0uZSgyKV0pKTtcbiAgICBjcHMucHVzaChjZW50cm9pZHNbY29scyAtIDFdKTtcbiAgICByZXR1cm4gY3BzO1xuICB9XG5cbiAgcGMuc2hhZG93cyA9IGZ1bmN0aW9uICgpIHtcbiAgICBmbGFncy5zaGFkb3dzID0gdHJ1ZTtcbiAgICBwYy5hbHBoYU9uQnJ1c2hlZCgwLjEpO1xuICAgIHBjLnJlbmRlcigpO1xuICAgIHJldHVybiB0aGlzO1xuICB9OyAvLyBkcmF3IGRvdHMgd2l0aCByYWRpdXMgciBvbiB0aGUgYXhpcyBsaW5lIHdoZXJlIGRhdGEgaW50ZXJzZWN0c1xuXG5cbiAgcGMuYXhpc0RvdHMgPSBmdW5jdGlvbiAocikge1xuICAgIHZhciByID0gciB8fCAwLjE7XG4gICAgdmFyIGN0eCA9IHBjLmN0eC5tYXJrcztcbiAgICB2YXIgc3RhcnRBbmdsZSA9IDA7XG4gICAgdmFyIGVuZEFuZ2xlID0gMiAqIE1hdGguUEk7XG4gICAgY3R4Lmdsb2JhbEFscGhhID0gZDMubWluKFsxIC8gTWF0aC5wb3coX18uZGF0YS5sZW5ndGgsIDEgLyAyKSwgMV0pO1xuXG4gICAgX18uZGF0YS5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgICBfXy5kaW1lbnNpb25zLm1hcChmdW5jdGlvbiAocCwgaSkge1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5hcmMocG9zaXRpb24ocCksIHlzY2FsZVtwXShkW3BdKSwgciwgc3RhcnRBbmdsZSwgZW5kQW5nbGUpO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgIGN0eC5maWxsKCk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9OyAvLyBkcmF3IHNpbmdsZSBjdWJpYyBiZXppZXIgY3VydmVcblxuXG4gIGZ1bmN0aW9uIHNpbmdsZV9jdXJ2ZShkLCBjdHgpIHtcbiAgICB2YXIgY2VudHJvaWRzID0gY29tcHV0ZV9jZW50cm9pZHMoZCk7XG4gICAgdmFyIGNwcyA9IGNvbXB1dGVfY29udHJvbF9wb2ludHMoY2VudHJvaWRzKTtcbiAgICBjdHgubW92ZVRvKGNwc1swXS5lKDEpLCBjcHNbMF0uZSgyKSk7XG5cbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGNwcy5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgaWYgKF9fLnNob3dDb250cm9sUG9pbnRzKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgMzsgaisrKSB7XG4gICAgICAgICAgY3R4LmZpbGxSZWN0KGNwc1tpICsgal0uZSgxKSwgY3BzW2kgKyBqXS5lKDIpLCAyLCAyKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjdHguYmV6aWVyQ3VydmVUbyhjcHNbaV0uZSgxKSwgY3BzW2ldLmUoMiksIGNwc1tpICsgMV0uZSgxKSwgY3BzW2kgKyAxXS5lKDIpLCBjcHNbaSArIDJdLmUoMSksIGNwc1tpICsgMl0uZSgyKSk7XG4gICAgfVxuICB9IC8vIGRyYXcgc2luZ2xlIHBvbHlsaW5lXG5cblxuICBmdW5jdGlvbiBjb2xvcl9wYXRoKGQsIGN0eCkge1xuICAgIGN0eC5iZWdpblBhdGgoKTtcblxuICAgIGlmIChfXy5idW5kbGVEaW1lbnNpb24gIT09IG51bGwgJiYgX18uYnVuZGxpbmdTdHJlbmd0aCA+IDAgfHwgX18uc21vb3RobmVzcyA+IDApIHtcbiAgICAgIHNpbmdsZV9jdXJ2ZShkLCBjdHgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzaW5nbGVfcGF0aChkLCBjdHgpO1xuICAgIH1cblxuICAgIGN0eC5zdHJva2UoKTtcbiAgfSAvLyBkcmF3IG1hbnkgcG9seWxpbmVzIG9mIHRoZSBzYW1lIGNvbG9yXG5cblxuICBmdW5jdGlvbiBwYXRocyhkYXRhLCBjdHgpIHtcbiAgICBjdHguY2xlYXJSZWN0KC0xLCAtMSwgdygpICsgMiwgaCgpICsgMik7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgaWYgKF9fLmJ1bmRsZURpbWVuc2lvbiAhPT0gbnVsbCAmJiBfXy5idW5kbGluZ1N0cmVuZ3RoID4gMCB8fCBfXy5zbW9vdGhuZXNzID4gMCkge1xuICAgICAgICBzaW5nbGVfY3VydmUoZCwgY3R4KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNpbmdsZV9wYXRoKGQsIGN0eCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgY3R4LnN0cm9rZSgpO1xuICB9IC8vIHJldHVybnMgdGhlIHktcG9zaXRpb24ganVzdCBiZXlvbmQgdGhlIHNlcGFyYXRpbmcgbnVsbCB2YWx1ZSBsaW5lXG5cblxuICBmdW5jdGlvbiBnZXROdWxsUG9zaXRpb24oKSB7XG4gICAgaWYgKF9fLm51bGxWYWx1ZVNlcGFyYXRvciA9PSAnYm90dG9tJykge1xuICAgICAgcmV0dXJuIGgoKSArIDE7XG4gICAgfSBlbHNlIGlmIChfXy5udWxsVmFsdWVTZXBhcmF0b3IgPT0gJ3RvcCcpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmxvZyhcIkEgdmFsdWUgaXMgTlVMTCwgYnV0IG51bGxWYWx1ZVNlcGFyYXRvciBpcyBub3Qgc2V0OyBzZXQgaXQgdG8gJ2JvdHRvbScgb3IgJ3RvcCcuXCIpO1xuICAgIH1cblxuICAgIHJldHVybiBoKCkgKyAxO1xuICB9XG5cbiAgZnVuY3Rpb24gc2luZ2xlX3BhdGgoZCwgY3R4KSB7XG4gICAgX18uZGltZW5zaW9ucy5tYXAoZnVuY3Rpb24gKHAsIGkpIHtcbiAgICAgIGlmIChpID09IDApIHtcbiAgICAgICAgY3R4Lm1vdmVUbyhwb3NpdGlvbihwKSwgdHlwZW9mIGRbcF0gPT0gJ3VuZGVmaW5lZCcgPyBnZXROdWxsUG9zaXRpb24oKSA6IHlzY2FsZVtwXShkW3BdKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdHgubGluZVRvKHBvc2l0aW9uKHApLCB0eXBlb2YgZFtwXSA9PSAndW5kZWZpbmVkJyA/IGdldE51bGxQb3NpdGlvbigpIDogeXNjYWxlW3BdKGRbcF0pKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhdGhfYnJ1c2hlZChkLCBpKSB7XG4gICAgaWYgKF9fLmJydXNoZWRDb2xvciAhPT0gbnVsbCkge1xuICAgICAgY3R4LmJydXNoZWQuc3Ryb2tlU3R5bGUgPSBkMy5mdW5jdG9yKF9fLmJydXNoZWRDb2xvcikoZCwgaSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN0eC5icnVzaGVkLnN0cm9rZVN0eWxlID0gZDMuZnVuY3RvcihfXy5jb2xvcikoZCwgaSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbG9yX3BhdGgoZCwgY3R4LmJydXNoZWQpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGF0aF9mb3JlZ3JvdW5kKGQsIGkpIHtcbiAgICBjdHguZm9yZWdyb3VuZC5zdHJva2VTdHlsZSA9IGQzLmZ1bmN0b3IoX18uY29sb3IpKGQsIGkpO1xuICAgIHJldHVybiBjb2xvcl9wYXRoKGQsIGN0eC5mb3JlZ3JvdW5kKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhdGhfaGlnaGxpZ2h0KGQsIGkpIHtcbiAgICBjdHguaGlnaGxpZ2h0LnN0cm9rZVN0eWxlID0gZDMuZnVuY3RvcihfXy5jb2xvcikoZCwgaSk7XG4gICAgcmV0dXJuIGNvbG9yX3BhdGgoZCwgY3R4LmhpZ2hsaWdodCk7XG4gIH1cblxuICBwYy5jbGVhciA9IGZ1bmN0aW9uIChsYXllcikge1xuICAgIGN0eFtsYXllcl0uY2xlYXJSZWN0KDAsIDAsIHcoKSArIDIsIGgoKSArIDIpOyAvLyBUaGlzIHdpbGwgbWFrZSBzdXJlIHRoYXQgdGhlIGZvcmVncm91bmQgaXRlbXMgYXJlIHRyYW5zcGFyZW50XG4gICAgLy8gd2l0aG91dCB0aGUgbmVlZCBmb3IgY2hhbmdpbmcgdGhlIG9wYWNpdHkgc3R5bGUgb2YgdGhlIGZvcmVncm91bmQgY2FudmFzXG4gICAgLy8gYXMgdGhpcyB3b3VsZCBzdG9wIHRoZSBjc3Mgc3R5bGluZyBmcm9tIHdvcmtpbmdcblxuICAgIGlmIChsYXllciA9PT0gJ2JydXNoZWQnICYmIGlzQnJ1c2hlZCgpKSB7XG4gICAgICBjdHguYnJ1c2hlZC5maWxsU3R5bGUgPSBwYy5zZWxlY3Rpb24uc3R5bGUoJ2JhY2tncm91bmQtY29sb3InKTtcbiAgICAgIGN0eC5icnVzaGVkLmdsb2JhbEFscGhhID0gMSAtIF9fLmFscGhhT25CcnVzaGVkO1xuICAgICAgY3R4LmJydXNoZWQuZmlsbFJlY3QoMCwgMCwgdygpICsgMiwgaCgpICsgMik7XG4gICAgICBjdHguYnJ1c2hlZC5nbG9iYWxBbHBoYSA9IF9fLmFscGhhO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIGQzLnJlYmluZChwYywgYXhpcywgJ3RpY2tzJywgJ29yaWVudCcsICd0aWNrVmFsdWVzJywgJ3RpY2tTdWJkaXZpZGUnLCAndGlja1NpemUnLCAndGlja1BhZGRpbmcnLCAndGlja0Zvcm1hdCcpO1xuXG4gIGZ1bmN0aW9uIGZsaXBBeGlzQW5kVXBkYXRlUENQKGRpbWVuc2lvbikge1xuICAgIHZhciBnID0gcGMuc3ZnLnNlbGVjdEFsbCgnLmRpbWVuc2lvbicpO1xuICAgIHBjLmZsaXAoZGltZW5zaW9uKTtcbiAgICBkMy5zZWxlY3QodGhpcy5wYXJlbnRFbGVtZW50KS50cmFuc2l0aW9uKCkuZHVyYXRpb24oMTEwMCkuY2FsbChheGlzLnNjYWxlKHlzY2FsZVtkaW1lbnNpb25dKSk7XG4gICAgcGMucmVuZGVyKCk7XG4gIH1cblxuICBmdW5jdGlvbiByb3RhdGVMYWJlbHMoKSB7XG4gICAgdmFyIGRlbHRhID0gZDMuZXZlbnQuZGVsdGFZO1xuICAgIGRlbHRhID0gZGVsdGEgPCAwID8gLTUgOiBkZWx0YTtcbiAgICBkZWx0YSA9IGRlbHRhID4gMCA/IDUgOiBkZWx0YTtcbiAgICBfXy5kaW1lbnNpb25UaXRsZVJvdGF0aW9uICs9IGRlbHRhO1xuICAgIHBjLnN2Zy5zZWxlY3RBbGwoJ3RleHQubGFiZWwnKS5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKDAsLTUpIHJvdGF0ZSgnICsgX18uZGltZW5zaW9uVGl0bGVSb3RhdGlvbiArICcpJyk7XG4gICAgZDMuZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRpbWVuc2lvbkxhYmVscyhkKSB7XG4gICAgcmV0dXJuIGQgaW4gX18uZGltZW5zaW9uVGl0bGVzID8gX18uZGltZW5zaW9uVGl0bGVzW2RdIDogZDsgLy8gZGltZW5zaW9uIGRpc3BsYXkgbmFtZXNcbiAgfVxuXG4gIHBjLmNyZWF0ZUF4ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGcpIHBjLnJlbW92ZUF4ZXMoKTsgLy8gQWRkIGEgZ3JvdXAgZWxlbWVudCBmb3IgZWFjaCBkaW1lbnNpb24uXG5cbiAgICBnID0gcGMuc3ZnLnNlbGVjdEFsbCgnLmRpbWVuc2lvbicpLmRhdGEoX18uZGltZW5zaW9ucywgZnVuY3Rpb24gKGQpIHtcbiAgICAgIHJldHVybiBkO1xuICAgIH0pLmVudGVyKCkuYXBwZW5kKCdzdmc6ZycpLmF0dHIoJ2NsYXNzJywgJ2RpbWVuc2lvbicpLmF0dHIoJ3RyYW5zZm9ybScsIGZ1bmN0aW9uIChkKSB7XG4gICAgICByZXR1cm4gJ3RyYW5zbGF0ZSgnICsgeHNjYWxlKGQpICsgJyknO1xuICAgIH0pOyAvLyBBZGQgYW4gYXhpcyBhbmQgdGl0bGUuXG5cbiAgICBnLmFwcGVuZCgnc3ZnOmcnKS5hdHRyKCdjbGFzcycsICdheGlzJykuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgwLDApJykuZWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgZDMuc2VsZWN0KHRoaXMpLmNhbGwoYXhpcy5zY2FsZSh5c2NhbGVbZF0pKTtcbiAgICB9KS5hcHBlbmQoJ3N2Zzp0ZXh0JykuYXR0cih7XG4gICAgICAndGV4dC1hbmNob3InOiAnbWlkZGxlJyxcbiAgICAgIHk6IDAsXG4gICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUoMCwtNSkgcm90YXRlKCcgKyBfXy5kaW1lbnNpb25UaXRsZVJvdGF0aW9uICsgJyknLFxuICAgICAgeDogMCxcbiAgICAgIGNsYXNzOiAnbGFiZWwnXG4gICAgfSkudGV4dChkaW1lbnNpb25MYWJlbHMpLm9uKCdkYmxjbGljaycsIGZsaXBBeGlzQW5kVXBkYXRlUENQKS5vbignd2hlZWwnLCByb3RhdGVMYWJlbHMpO1xuXG4gICAgaWYgKF9fLm51bGxWYWx1ZVNlcGFyYXRvciA9PSAndG9wJykge1xuICAgICAgcGMuc3ZnLmFwcGVuZCgnbGluZScpLmF0dHIoJ3gxJywgMCkuYXR0cigneTEnLCAxICsgX18ubnVsbFZhbHVlU2VwYXJhdG9yUGFkZGluZy50b3ApLmF0dHIoJ3gyJywgdygpKS5hdHRyKCd5MicsIDEgKyBfXy5udWxsVmFsdWVTZXBhcmF0b3JQYWRkaW5nLnRvcCkuYXR0cignc3Ryb2tlLXdpZHRoJywgMSkuYXR0cignc3Ryb2tlJywgJyM3NzcnKS5hdHRyKCdmaWxsJywgJ25vbmUnKS5hdHRyKCdzaGFwZS1yZW5kZXJpbmcnLCAnY3Jpc3BFZGdlcycpO1xuICAgIH0gZWxzZSBpZiAoX18ubnVsbFZhbHVlU2VwYXJhdG9yID09ICdib3R0b20nKSB7XG4gICAgICBwYy5zdmcuYXBwZW5kKCdsaW5lJykuYXR0cigneDEnLCAwKS5hdHRyKCd5MScsIGgoKSArIDEgLSBfXy5udWxsVmFsdWVTZXBhcmF0b3JQYWRkaW5nLmJvdHRvbSkuYXR0cigneDInLCB3KCkpLmF0dHIoJ3kyJywgaCgpICsgMSAtIF9fLm51bGxWYWx1ZVNlcGFyYXRvclBhZGRpbmcuYm90dG9tKS5hdHRyKCdzdHJva2Utd2lkdGgnLCAxKS5hdHRyKCdzdHJva2UnLCAnIzc3NycpLmF0dHIoJ2ZpbGwnLCAnbm9uZScpLmF0dHIoJ3NoYXBlLXJlbmRlcmluZycsICdjcmlzcEVkZ2VzJyk7XG4gICAgfVxuXG4gICAgZmxhZ3MuYXhlcyA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgcGMucmVtb3ZlQXhlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICBnLnJlbW92ZSgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHBjLnVwZGF0ZUF4ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGdfZGF0YSA9IHBjLnN2Zy5zZWxlY3RBbGwoJy5kaW1lbnNpb24nKS5kYXRhKF9fLmRpbWVuc2lvbnMpOyAvLyBFbnRlclxuXG4gICAgZ19kYXRhLmVudGVyKCkuYXBwZW5kKCdzdmc6ZycpLmF0dHIoJ2NsYXNzJywgJ2RpbWVuc2lvbicpLmF0dHIoJ3RyYW5zZm9ybScsIGZ1bmN0aW9uIChwKSB7XG4gICAgICByZXR1cm4gJ3RyYW5zbGF0ZSgnICsgcG9zaXRpb24ocCkgKyAnKSc7XG4gICAgfSkuc3R5bGUoJ29wYWNpdHknLCAwKS5hcHBlbmQoJ3N2ZzpnJykuYXR0cignY2xhc3MnLCAnYXhpcycpLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoMCwwKScpLmVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgIGQzLnNlbGVjdCh0aGlzKS5jYWxsKGF4aXMuc2NhbGUoeXNjYWxlW2RdKSk7XG4gICAgfSkuYXBwZW5kKCdzdmc6dGV4dCcpLmF0dHIoe1xuICAgICAgJ3RleHQtYW5jaG9yJzogJ21pZGRsZScsXG4gICAgICB5OiAwLFxuICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlKDAsLTUpIHJvdGF0ZSgnICsgX18uZGltZW5zaW9uVGl0bGVSb3RhdGlvbiArICcpJyxcbiAgICAgIHg6IDAsXG4gICAgICBjbGFzczogJ2xhYmVsJ1xuICAgIH0pLnRleHQoZGltZW5zaW9uTGFiZWxzKS5vbignZGJsY2xpY2snLCBmbGlwQXhpc0FuZFVwZGF0ZVBDUCkub24oJ3doZWVsJywgcm90YXRlTGFiZWxzKTsgLy8gVXBkYXRlXG5cbiAgICBnX2RhdGEuYXR0cignb3BhY2l0eScsIDApO1xuICAgIGdfZGF0YS5zZWxlY3QoJy5heGlzJykudHJhbnNpdGlvbigpLmR1cmF0aW9uKDExMDApLmVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgIGQzLnNlbGVjdCh0aGlzKS5jYWxsKGF4aXMuc2NhbGUoeXNjYWxlW2RdKSk7XG4gICAgfSk7XG4gICAgZ19kYXRhLnNlbGVjdCgnLmxhYmVsJykudHJhbnNpdGlvbigpLmR1cmF0aW9uKDExMDApLnRleHQoZGltZW5zaW9uTGFiZWxzKS5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKDAsLTUpIHJvdGF0ZSgnICsgX18uZGltZW5zaW9uVGl0bGVSb3RhdGlvbiArICcpJyk7IC8vIEV4aXRcblxuICAgIGdfZGF0YS5leGl0KCkucmVtb3ZlKCk7XG4gICAgZyA9IHBjLnN2Zy5zZWxlY3RBbGwoJy5kaW1lbnNpb24nKTtcbiAgICBnLnRyYW5zaXRpb24oKS5kdXJhdGlvbigxMTAwKS5hdHRyKCd0cmFuc2Zvcm0nLCBmdW5jdGlvbiAocCkge1xuICAgICAgcmV0dXJuICd0cmFuc2xhdGUoJyArIHBvc2l0aW9uKHApICsgJyknO1xuICAgIH0pLnN0eWxlKCdvcGFjaXR5JywgMSk7XG4gICAgcGMuc3ZnLnNlbGVjdEFsbCgnLmF4aXMnKS50cmFuc2l0aW9uKCkuZHVyYXRpb24oMTEwMCkuZWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgZDMuc2VsZWN0KHRoaXMpLmNhbGwoYXhpcy5zY2FsZSh5c2NhbGVbZF0pKTtcbiAgICB9KTtcbiAgICBpZiAoZmxhZ3MuYnJ1c2hhYmxlKSBwYy5icnVzaGFibGUoKTtcbiAgICBpZiAoZmxhZ3MucmVvcmRlcmFibGUpIHBjLnJlb3JkZXJhYmxlKCk7XG5cbiAgICBpZiAocGMuYnJ1c2hNb2RlKCkgIT09ICdOb25lJykge1xuICAgICAgdmFyIG1vZGUgPSBwYy5icnVzaE1vZGUoKTtcbiAgICAgIHBjLmJydXNoTW9kZSgnTm9uZScpO1xuICAgICAgcGMuYnJ1c2hNb2RlKG1vZGUpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9OyAvLyBKYXNvbiBEYXZpZXMsIGh0dHA6Ly9ibC5vY2tzLm9yZy8xMzQxMjgxXG5cblxuICBwYy5yZW9yZGVyYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIWcpIHBjLmNyZWF0ZUF4ZXMoKTtcbiAgICBnLnN0eWxlKCdjdXJzb3InLCAnbW92ZScpLmNhbGwoZDMuYmVoYXZpb3IuZHJhZygpLm9uKCdkcmFnc3RhcnQnLCBmdW5jdGlvbiAoZCkge1xuICAgICAgZHJhZ2dpbmdbZF0gPSB0aGlzLl9fb3JpZ2luX18gPSB4c2NhbGUoZCk7XG4gICAgfSkub24oJ2RyYWcnLCBmdW5jdGlvbiAoZCkge1xuICAgICAgZHJhZ2dpbmdbZF0gPSBNYXRoLm1pbih3KCksIE1hdGgubWF4KDAsIHRoaXMuX19vcmlnaW5fXyArPSBkMy5ldmVudC5keCkpO1xuXG4gICAgICBfXy5kaW1lbnNpb25zLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIHBvc2l0aW9uKGEpIC0gcG9zaXRpb24oYik7XG4gICAgICB9KTtcblxuICAgICAgeHNjYWxlLmRvbWFpbihfXy5kaW1lbnNpb25zKTtcbiAgICAgIHBjLnJlbmRlcigpO1xuICAgICAgZy5hdHRyKCd0cmFuc2Zvcm0nLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4gJ3RyYW5zbGF0ZSgnICsgcG9zaXRpb24oZCkgKyAnKSc7XG4gICAgICB9KTtcbiAgICB9KS5vbignZHJhZ2VuZCcsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAvLyBMZXQncyBzZWUgaWYgdGhlIG9yZGVyIGhhcyBjaGFuZ2VkIGFuZCBzZW5kIG91dCBhbiBldmVudCBpZiBzby5cbiAgICAgIHZhciBpID0gMCxcbiAgICAgICAgICBqID0gX18uZGltZW5zaW9ucy5pbmRleE9mKGQpLFxuICAgICAgICAgIGVsZW0gPSB0aGlzLFxuICAgICAgICAgIHBhcmVudCA9IHRoaXMucGFyZW50RWxlbWVudDtcblxuICAgICAgd2hpbGUgKChlbGVtID0gZWxlbS5wcmV2aW91c0VsZW1lbnRTaWJsaW5nKSAhPSBudWxsKSArK2k7XG5cbiAgICAgIGlmIChpICE9PSBqKSB7XG4gICAgICAgIGV2ZW50cy5heGVzcmVvcmRlci5jYWxsKHBjLCBfXy5kaW1lbnNpb25zKTsgLy8gV2Ugbm93IGFsc28gd2FudCB0byByZW9yZGVyIHRoZSBhY3R1YWwgZG9tIGVsZW1lbnRzIHRoYXQgcmVwcmVzZW50XG4gICAgICAgIC8vIHRoZSBheGVzLiBUaGF0IGlzLCB0aGUgZy5kaW1lbnNpb24gZWxlbWVudHMuIElmIHdlIGRvbid0IGRvIHRoaXMsXG4gICAgICAgIC8vIHdlIGdldCBhIHdlaXJkIGFuZCBjb25mdXNpbmcgdHJhbnNpdGlvbiB3aGVuIHVwZGF0ZUF4ZXMgaXMgY2FsbGVkLlxuICAgICAgICAvLyBUaGlzIGlzIGR1ZSB0byB0aGUgZmFjdCB0aGF0LCBpbml0aWFsbHkgdGhlIG50aCBnLmRpbWVuc2lvbiBlbGVtZW50XG4gICAgICAgIC8vIHJlcHJlc2VudHMgdGhlIG50aCBheGlzLiBIb3dldmVyLCBhZnRlciBhIG1hbnVhbCByZW9yZGVyaW5nLFxuICAgICAgICAvLyB3aXRob3V0IHJlb3JkZXJpbmcgdGhlIGRvbSBlbGVtZW50cywgdGhlIG50aCBkb20gZWxlbWVudHMgbm8gbG9uZ2VyXG4gICAgICAgIC8vIG5lY2Vzc2FyaWx5IHJlcHJlc2VudHMgdGhlIG50aCBheGlzLlxuICAgICAgICAvL1xuICAgICAgICAvLyBpIGlzIHRoZSBvcmlnaW5hbCBpbmRleCBvZiB0aGUgZG9tIGVsZW1lbnRcbiAgICAgICAgLy8gaiBpcyB0aGUgbmV3IGluZGV4IG9mIHRoZSBkb20gZWxlbWVudFxuXG4gICAgICAgIGlmIChpID4gaikge1xuICAgICAgICAgIC8vIEVsZW1lbnQgbW92ZWQgbGVmdFxuICAgICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUodGhpcywgcGFyZW50LmNoaWxkcmVuW2ogLSAxXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gRWxlbWVudCBtb3ZlZCByaWdodFxuICAgICAgICAgIGlmIChqICsgMSA8IHBhcmVudC5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUodGhpcywgcGFyZW50LmNoaWxkcmVuW2ogKyAxXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcmVudC5hcHBlbmRDaGlsZCh0aGlzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZGVsZXRlIHRoaXMuX19vcmlnaW5fXztcbiAgICAgIGRlbGV0ZSBkcmFnZ2luZ1tkXTtcbiAgICAgIGQzLnNlbGVjdCh0aGlzKS50cmFuc2l0aW9uKCkuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgeHNjYWxlKGQpICsgJyknKTtcbiAgICAgIHBjLnJlbmRlcigpO1xuICAgIH0pKTtcbiAgICBmbGFncy5yZW9yZGVyYWJsZSA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07IC8vIFJlb3JkZXIgZGltZW5zaW9ucywgc3VjaCB0aGF0IHRoZSBoaWdoZXN0IHZhbHVlICh2aXN1YWxseSkgaXMgb24gdGhlIGxlZnQgYW5kXG4gIC8vIHRoZSBsb3dlc3Qgb24gdGhlIHJpZ2h0LiBWaXN1YWwgdmFsdWVzIGFyZSBkZXRlcm1pbmVkIGJ5IHRoZSBkYXRhIHZhbHVlcyBpblxuICAvLyB0aGUgZ2l2ZW4gcm93LlxuXG5cbiAgcGMucmVvcmRlciA9IGZ1bmN0aW9uIChyb3dkYXRhKSB7XG4gICAgdmFyIGRpbXMgPSBfXy5kaW1lbnNpb25zLnNsaWNlKDApO1xuXG4gICAgX18uZGltZW5zaW9ucy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICB2YXIgcGl4ZWxEaWZmZXJlbmNlID0geXNjYWxlW2FdKHJvd2RhdGFbYV0pIC0geXNjYWxlW2JdKHJvd2RhdGFbYl0pOyAvLyBBcnJheS5zb3J0IGlzIG5vdCBuZWNlc3NhcmlseSBzdGFibGUsIHRoaXMgbWVhbnMgdGhhdCBpZiBwaXhlbERpZmZlcmVuY2UgaXMgemVyb1xuICAgICAgLy8gdGhlIG9yZGVyaW5nIG9mIGRpbWVuc2lvbnMgbWlnaHQgY2hhbmdlIHVuZXhwZWN0ZWRseS4gVGhpcyBpcyBzb2x2ZWQgYnkgc29ydGluZyBvblxuICAgICAgLy8gdmFyaWFibGUgbmFtZSBpbiB0aGF0IGNhc2UuXG5cbiAgICAgIGlmIChwaXhlbERpZmZlcmVuY2UgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGEubG9jYWxlQ29tcGFyZShiKTtcbiAgICAgIH0gLy8gZWxzZVxuXG5cbiAgICAgIHJldHVybiBwaXhlbERpZmZlcmVuY2U7XG4gICAgfSk7IC8vIE5PVEU6IHRoaXMgaXMgcmVsYXRpdmVseSBjaGVhcCBnaXZlbiB0aGF0OlxuICAgIC8vIG51bWJlciBvZiBkaW1lbnNpb25zIDwgbnVtYmVyIG9mIGRhdGEgaXRlbXNcbiAgICAvLyBUaHVzIHdlIGNoZWNrIGVxdWFsaXR5IG9mIG9yZGVyIHRvIHByZXZlbnQgcmVyZW5kZXJpbmcgd2hlbiB0aGlzIGlzIHRoZSBjYXNlLlxuXG5cbiAgICB2YXIgcmVvcmRlcmVkID0gZmFsc2U7XG4gICAgZGltcy5zb21lKGZ1bmN0aW9uICh2YWwsIGluZGV4KSB7XG4gICAgICByZW9yZGVyZWQgPSB2YWwgIT09IF9fLmRpbWVuc2lvbnNbaW5kZXhdO1xuICAgICAgcmV0dXJuIHJlb3JkZXJlZDtcbiAgICB9KTtcblxuICAgIGlmIChyZW9yZGVyZWQpIHtcbiAgICAgIHhzY2FsZS5kb21haW4oX18uZGltZW5zaW9ucyk7XG5cbiAgICAgIHZhciBoaWdobGlnaHRlZCA9IF9fLmhpZ2hsaWdodGVkLnNsaWNlKDApO1xuXG4gICAgICBwYy51bmhpZ2hsaWdodCgpO1xuICAgICAgZy50cmFuc2l0aW9uKCkuZHVyYXRpb24oMTUwMCkuYXR0cigndHJhbnNmb3JtJywgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuICd0cmFuc2xhdGUoJyArIHhzY2FsZShkKSArICcpJztcbiAgICAgIH0pO1xuICAgICAgcGMucmVuZGVyKCk7IC8vIHBjLmhpZ2hsaWdodCgpIGRvZXMgbm90IGNoZWNrIHdoZXRoZXIgaGlnaGxpZ2h0ZWQgaXMgbGVuZ3RoIHplcm8sIHNvIHdlIGRvIHRoYXQgaGVyZS5cblxuICAgICAgaWYgKGhpZ2hsaWdodGVkLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICBwYy5oaWdobGlnaHQoaGlnaGxpZ2h0ZWQpO1xuICAgICAgfVxuICAgIH1cbiAgfTsgLy8gcGFpcnMgb2YgYWRqYWNlbnQgZGltZW5zaW9uc1xuXG5cbiAgcGMuYWRqYWNlbnRfcGFpcnMgPSBmdW5jdGlvbiAoYXJyKSB7XG4gICAgdmFyIHJldCA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICByZXQucHVzaChbYXJyW2ldLCBhcnJbaSArIDFdXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcbiAgfTtcblxuICB2YXIgYnJ1c2ggPSB7XG4gICAgbW9kZXM6IHtcbiAgICAgIE5vbmU6IHtcbiAgICAgICAgaW5zdGFsbDogZnVuY3Rpb24gaW5zdGFsbChwYykge30sXG4gICAgICAgIC8vIE5vdGhpbmcgdG8gYmUgZG9uZS5cbiAgICAgICAgdW5pbnN0YWxsOiBmdW5jdGlvbiB1bmluc3RhbGwocGMpIHt9LFxuICAgICAgICAvLyBOb3RoaW5nIHRvIGJlIGRvbmUuXG4gICAgICAgIHNlbGVjdGVkOiBmdW5jdGlvbiBzZWxlY3RlZCgpIHtcbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH0sXG4gICAgICAgIC8vIE5vdGhpbmcgdG8gcmV0dXJuXG4gICAgICAgIGJydXNoU3RhdGU6IGZ1bmN0aW9uIGJydXNoU3RhdGUoKSB7XG4gICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBtb2RlOiAnTm9uZScsXG4gICAgcHJlZGljYXRlOiAnQU5EJyxcbiAgICBjdXJyZW50TW9kZTogZnVuY3Rpb24gY3VycmVudE1vZGUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tb2Rlc1t0aGlzLm1vZGVdO1xuICAgIH1cbiAgfTsgLy8gVGhpcyBmdW5jdGlvbiBjYW4gYmUgdXNlZCBmb3IgJ2xpdmUnIHVwZGF0ZXMgb2YgYnJ1c2hlcy4gVGhhdCBpcywgZHVyaW5nIHRoZVxuICAvLyBzcGVjaWZpY2F0aW9uIG9mIGEgYnJ1c2gsIHRoaXMgbWV0aG9kIGNhbiBiZSBjYWxsZWQgdG8gdXBkYXRlIHRoZSB2aWV3LlxuICAvL1xuICAvLyBAcGFyYW0gbmV3U2VsZWN0aW9uIC0gVGhlIG5ldyBzZXQgb2YgZGF0YSBpdGVtcyB0aGF0IGlzIGN1cnJlbnRseSBjb250YWluZWRcbiAgLy8gICAgICAgICAgICAgICAgICAgICAgIGJ5IHRoZSBicnVzaGVzXG5cbiAgZnVuY3Rpb24gYnJ1c2hVcGRhdGVkKG5ld1NlbGVjdGlvbikge1xuICAgIF9fLmJydXNoZWQgPSBuZXdTZWxlY3Rpb247XG4gICAgZXZlbnRzLmJydXNoLmNhbGwocGMsIF9fLmJydXNoZWQpO1xuICAgIHBjLnJlbmRlckJydXNoZWQoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGJydXNoUHJlZGljYXRlKHByZWRpY2F0ZSkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGJydXNoLnByZWRpY2F0ZTtcbiAgICB9XG5cbiAgICBwcmVkaWNhdGUgPSBTdHJpbmcocHJlZGljYXRlKS50b1VwcGVyQ2FzZSgpO1xuXG4gICAgaWYgKHByZWRpY2F0ZSAhPT0gJ0FORCcgJiYgcHJlZGljYXRlICE9PSAnT1InKSB7XG4gICAgICB0aHJvdyAnSW52YWxpZCBwcmVkaWNhdGUgJyArIHByZWRpY2F0ZTtcbiAgICB9XG5cbiAgICBicnVzaC5wcmVkaWNhdGUgPSBwcmVkaWNhdGU7XG4gICAgX18uYnJ1c2hlZCA9IGJydXNoLmN1cnJlbnRNb2RlKCkuc2VsZWN0ZWQoKTtcbiAgICBwYy5yZW5kZXJCcnVzaGVkKCk7XG4gICAgcmV0dXJuIHBjO1xuICB9XG5cbiAgcGMuYnJ1c2hNb2RlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYnJ1c2gubW9kZXMpO1xuICB9O1xuXG4gIHBjLmJydXNoTW9kZSA9IGZ1bmN0aW9uIChtb2RlKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBicnVzaC5tb2RlO1xuICAgIH1cblxuICAgIGlmIChwYy5icnVzaE1vZGVzKCkuaW5kZXhPZihtb2RlKSA9PT0gLTEpIHtcbiAgICAgIHRocm93ICdwYy5icnVzaG1vZGU6IFVuc3VwcG9ydGVkIGJydXNoIG1vZGU6ICcgKyBtb2RlO1xuICAgIH0gLy8gTWFrZSBzdXJlIHRoYXQgd2UgZG9uJ3QgdHJpZ2dlciB1bm5lY2Vzc2FyeSBldmVudHMgYnkgY2hlY2tpbmcgaWYgdGhlIG1vZGVcbiAgICAvLyBhY3R1YWxseSBjaGFuZ2VzLlxuXG5cbiAgICBpZiAobW9kZSAhPT0gYnJ1c2gubW9kZSkge1xuICAgICAgLy8gV2hlbiBjaGFuZ2luZyBicnVzaCBtb2RlcywgdGhlIGZpcnN0IHRoaW5nIHdlIG5lZWQgdG8gZG8gaXMgY2xlYXJpbmcgYW55XG4gICAgICAvLyBicnVzaGVzIGZyb20gdGhlIGN1cnJlbnQgbW9kZSwgaWYgYW55LlxuICAgICAgaWYgKGJydXNoLm1vZGUgIT09ICdOb25lJykge1xuICAgICAgICBwYy5icnVzaFJlc2V0KCk7XG4gICAgICB9IC8vIE5leHQsIHdlIG5lZWQgdG8gJ3VuaW5zdGFsbCcgdGhlIGN1cnJlbnQgYnJ1c2hNb2RlLlxuXG5cbiAgICAgIGJydXNoLm1vZGVzW2JydXNoLm1vZGVdLnVuaW5zdGFsbChwYyk7IC8vIEZpbmFsbHksIHdlIGNhbiBpbnN0YWxsIHRoZSByZXF1ZXN0ZWQgb25lLlxuXG4gICAgICBicnVzaC5tb2RlID0gbW9kZTtcbiAgICAgIGJydXNoLm1vZGVzW2JydXNoLm1vZGVdLmluc3RhbGwoKTtcblxuICAgICAgaWYgKG1vZGUgPT09ICdOb25lJykge1xuICAgICAgICBkZWxldGUgcGMuYnJ1c2hQcmVkaWNhdGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYy5icnVzaFByZWRpY2F0ZSA9IGJydXNoUHJlZGljYXRlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBwYztcbiAgfTsgLy8gYnJ1c2ggbW9kZTogMUQtQXhlc1xuXG5cbiAgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYnJ1c2hlcyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gaXNfYnJ1c2hlZChwKSB7XG4gICAgICByZXR1cm4gIWJydXNoZXNbcF0uZW1wdHkoKTtcbiAgICB9IC8vIGRhdGEgd2l0aGluIGV4dGVudHNcblxuXG4gICAgZnVuY3Rpb24gc2VsZWN0ZWQoKSB7XG4gICAgICB2YXIgYWN0aXZlcyA9IF9fLmRpbWVuc2lvbnMuZmlsdGVyKGlzX2JydXNoZWQpLFxuICAgICAgICAgIGV4dGVudHMgPSBhY3RpdmVzLm1hcChmdW5jdGlvbiAocCkge1xuICAgICAgICByZXR1cm4gYnJ1c2hlc1twXS5leHRlbnQoKTtcbiAgICAgIH0pOyAvLyBXZSBkb24ndCB3YW50IHRvIHJldHVybiB0aGUgZnVsbCBkYXRhIHNldCB3aGVuIHRoZXJlIGFyZSBubyBheGVzIGJydXNoZWQuXG4gICAgICAvLyBBY3R1YWxseSwgd2hlbiB0aGVyZSBhcmUgbm8gYXhlcyBicnVzaGVkLCBieSBkZWZpbml0aW9uLCBubyBpdGVtcyBhcmVcbiAgICAgIC8vIHNlbGVjdGVkLiBTbywgbGV0J3MgYXZvaWQgdGhlIGZpbHRlcmluZyBhbmQganVzdCByZXR1cm4gZmFsc2UuXG4gICAgICAvL2lmIChhY3RpdmVzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGZhbHNlO1xuICAgICAgLy8gUmVzb2x2ZXMgYnJva2VuIGV4YW1wbGVzIGZvciBub3cuIFRoZXkgZXhwZWN0IHRvIGdldCB0aGUgZnVsbCBkYXRhc2V0IGJhY2sgZnJvbSBlbXB0eSBicnVzaGVzXG5cblxuICAgICAgaWYgKGFjdGl2ZXMubGVuZ3RoID09PSAwKSByZXR1cm4gX18uZGF0YTsgLy8gdGVzdCBpZiB3aXRoaW4gcmFuZ2VcblxuICAgICAgdmFyIHdpdGhpbiA9IHtcbiAgICAgICAgZGF0ZTogZnVuY3Rpb24gZGF0ZShkLCBwLCBkaW1lbnNpb24pIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHlzY2FsZVtwXS5yYW5nZVBvaW50cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgLy8gaWYgaXQgaXMgb3JkaW5hbFxuICAgICAgICAgICAgcmV0dXJuIGV4dGVudHNbZGltZW5zaW9uXVswXSA8PSB5c2NhbGVbcF0oZFtwXSkgJiYgeXNjYWxlW3BdKGRbcF0pIDw9IGV4dGVudHNbZGltZW5zaW9uXVsxXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGV4dGVudHNbZGltZW5zaW9uXVswXSA8PSBkW3BdICYmIGRbcF0gPD0gZXh0ZW50c1tkaW1lbnNpb25dWzFdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbnVtYmVyOiBmdW5jdGlvbiBudW1iZXIoZCwgcCwgZGltZW5zaW9uKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB5c2NhbGVbcF0ucmFuZ2VQb2ludHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vIGlmIGl0IGlzIG9yZGluYWxcbiAgICAgICAgICAgIHJldHVybiBleHRlbnRzW2RpbWVuc2lvbl1bMF0gPD0geXNjYWxlW3BdKGRbcF0pICYmIHlzY2FsZVtwXShkW3BdKSA8PSBleHRlbnRzW2RpbWVuc2lvbl1bMV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBleHRlbnRzW2RpbWVuc2lvbl1bMF0gPD0gZFtwXSAmJiBkW3BdIDw9IGV4dGVudHNbZGltZW5zaW9uXVsxXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHN0cmluZzogZnVuY3Rpb24gc3RyaW5nKGQsIHAsIGRpbWVuc2lvbikge1xuICAgICAgICAgIHJldHVybiBleHRlbnRzW2RpbWVuc2lvbl1bMF0gPD0geXNjYWxlW3BdKGRbcF0pICYmIHlzY2FsZVtwXShkW3BdKSA8PSBleHRlbnRzW2RpbWVuc2lvbl1bMV07XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZXR1cm4gX18uZGF0YS5maWx0ZXIoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgc3dpdGNoIChicnVzaC5wcmVkaWNhdGUpIHtcbiAgICAgICAgICBjYXNlICdBTkQnOlxuICAgICAgICAgICAgcmV0dXJuIGFjdGl2ZXMuZXZlcnkoZnVuY3Rpb24gKHAsIGRpbWVuc2lvbikge1xuICAgICAgICAgICAgICByZXR1cm4gd2l0aGluW19fLnR5cGVzW3BdXShkLCBwLCBkaW1lbnNpb24pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjYXNlICdPUic6XG4gICAgICAgICAgICByZXR1cm4gYWN0aXZlcy5zb21lKGZ1bmN0aW9uIChwLCBkaW1lbnNpb24pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHdpdGhpbltfXy50eXBlc1twXV0oZCwgcCwgZGltZW5zaW9uKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93ICdVbmtub3duIGJydXNoIHByZWRpY2F0ZSAnICsgX18uYnJ1c2hQcmVkaWNhdGU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJydXNoRXh0ZW50cyhleHRlbnRzKSB7XG4gICAgICBpZiAodHlwZW9mIGV4dGVudHMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHZhciBleHRlbnRzID0ge307XG5cbiAgICAgICAgX18uZGltZW5zaW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgdmFyIGJydXNoID0gYnJ1c2hlc1tkXTtcblxuICAgICAgICAgIGlmIChicnVzaCAhPT0gdW5kZWZpbmVkICYmICFicnVzaC5lbXB0eSgpKSB7XG4gICAgICAgICAgICB2YXIgZXh0ZW50ID0gYnJ1c2guZXh0ZW50KCk7XG4gICAgICAgICAgICBleHRlbnQuc29ydChkMy5hc2NlbmRpbmcpO1xuICAgICAgICAgICAgZXh0ZW50c1tkXSA9IGV4dGVudDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBleHRlbnRzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy9maXJzdCBnZXQgYWxsIHRoZSBicnVzaCBzZWxlY3Rpb25zXG4gICAgICAgIHZhciBicnVzaFNlbGVjdGlvbnMgPSB7fTtcbiAgICAgICAgZy5zZWxlY3RBbGwoJy5icnVzaCcpLmVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICBicnVzaFNlbGVjdGlvbnNbZF0gPSBkMy5zZWxlY3QodGhpcyk7XG4gICAgICAgIH0pOyAvLyBsb29wIG92ZXIgZWFjaCBkaW1lbnNpb24gYW5kIHVwZGF0ZSBhcHByb3ByaWF0ZWx5IChpZiBpdCB3YXMgcGFzc2VkIGluIHRocm91Z2ggZXh0ZW50cylcblxuICAgICAgICBfXy5kaW1lbnNpb25zLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICBpZiAoZXh0ZW50c1tkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGJydXNoID0gYnJ1c2hlc1tkXTtcblxuICAgICAgICAgIGlmIChicnVzaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvL3VwZGF0ZSB0aGUgZXh0ZW50XG4gICAgICAgICAgICBicnVzaC5leHRlbnQoZXh0ZW50c1tkXSk7IC8vcmVkcmF3IHRoZSBicnVzaFxuXG4gICAgICAgICAgICBicnVzaChicnVzaFNlbGVjdGlvbnNbZF0pOyAvL2ZpcmUgc29tZSBldmVudHNcblxuICAgICAgICAgICAgYnJ1c2guZXZlbnQoYnJ1c2hTZWxlY3Rpb25zW2RdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pOyAvL3JlZHJhdyB0aGUgY2hhcnRcblxuXG4gICAgICAgIHBjLnJlbmRlckJydXNoZWQoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBicnVzaEZvcihheGlzKSB7XG4gICAgICB2YXIgYnJ1c2ggPSBkMy5zdmcuYnJ1c2goKTtcbiAgICAgIGJydXNoLnkoeXNjYWxlW2F4aXNdKS5vbignYnJ1c2hzdGFydCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGQzLmV2ZW50LnNvdXJjZUV2ZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgZDMuZXZlbnQuc291cmNlRXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgIH0pLm9uKCdicnVzaCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgYnJ1c2hVcGRhdGVkKHNlbGVjdGVkKCkpO1xuICAgICAgfSkub24oJ2JydXNoZW5kJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBldmVudHMuYnJ1c2hlbmQuY2FsbChwYywgX18uYnJ1c2hlZCk7XG4gICAgICB9KTtcbiAgICAgIGJydXNoZXNbYXhpc10gPSBicnVzaDtcbiAgICAgIHJldHVybiBicnVzaDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBicnVzaFJlc2V0KGRpbWVuc2lvbikge1xuICAgICAgX18uYnJ1c2hlZCA9IGZhbHNlO1xuXG4gICAgICBpZiAoZykge1xuICAgICAgICBnLnNlbGVjdEFsbCgnLmJydXNoJykuZWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5jYWxsKGJydXNoZXNbZF0uY2xlYXIoKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBwYy5yZW5kZXJCcnVzaGVkKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGwoKSB7XG4gICAgICBpZiAoIWcpIHBjLmNyZWF0ZUF4ZXMoKTsgLy8gQWRkIGFuZCBzdG9yZSBhIGJydXNoIGZvciBlYWNoIGF4aXMuXG5cbiAgICAgIGcuYXBwZW5kKCdzdmc6ZycpLmF0dHIoJ2NsYXNzJywgJ2JydXNoJykuZWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgICBkMy5zZWxlY3QodGhpcykuY2FsbChicnVzaEZvcihkKSk7XG4gICAgICB9KS5zZWxlY3RBbGwoJ3JlY3QnKS5zdHlsZSgndmlzaWJpbGl0eScsIG51bGwpLmF0dHIoJ3gnLCAtMTUpLmF0dHIoJ3dpZHRoJywgMzApO1xuICAgICAgcGMuYnJ1c2hFeHRlbnRzID0gYnJ1c2hFeHRlbnRzO1xuICAgICAgcGMuYnJ1c2hSZXNldCA9IGJydXNoUmVzZXQ7XG4gICAgICByZXR1cm4gcGM7XG4gICAgfVxuXG4gICAgYnJ1c2gubW9kZXNbJzFELWF4ZXMnXSA9IHtcbiAgICAgIGluc3RhbGw6IGluc3RhbGwsXG4gICAgICB1bmluc3RhbGw6IGZ1bmN0aW9uIHVuaW5zdGFsbCgpIHtcbiAgICAgICAgZy5zZWxlY3RBbGwoJy5icnVzaCcpLnJlbW92ZSgpO1xuICAgICAgICBicnVzaGVzID0ge307XG4gICAgICAgIGRlbGV0ZSBwYy5icnVzaEV4dGVudHM7XG4gICAgICAgIGRlbGV0ZSBwYy5icnVzaFJlc2V0O1xuICAgICAgfSxcbiAgICAgIHNlbGVjdGVkOiBzZWxlY3RlZCxcbiAgICAgIGJydXNoU3RhdGU6IGJydXNoRXh0ZW50c1xuICAgIH07XG4gIH0pKCk7IC8vIGJydXNoIG1vZGU6IDJELXN0cnVtc1xuICAvLyBibC5vY2tzLm9yZy9zeW50YWdtYXRpYy81NDQxMDIyXG5cblxuICAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdHJ1bXMgPSB7fSxcbiAgICAgICAgc3RydW1SZWN0O1xuXG4gICAgZnVuY3Rpb24gZHJhd1N0cnVtKHN0cnVtLCBhY3RpdmVQb2ludCkge1xuICAgICAgdmFyIHN2ZyA9IHBjLnNlbGVjdGlvbi5zZWxlY3QoJ3N2ZycpLnNlbGVjdCgnZyNzdHJ1bXMnKSxcbiAgICAgICAgICBpZCA9IHN0cnVtLmRpbXMuaSxcbiAgICAgICAgICBwb2ludHMgPSBbc3RydW0ucDEsIHN0cnVtLnAyXSxcbiAgICAgICAgICBsaW5lID0gc3ZnLnNlbGVjdEFsbCgnbGluZSNzdHJ1bS0nICsgaWQpLmRhdGEoW3N0cnVtXSksXG4gICAgICAgICAgY2lyY2xlcyA9IHN2Zy5zZWxlY3RBbGwoJ2NpcmNsZSNzdHJ1bS0nICsgaWQpLmRhdGEocG9pbnRzKSxcbiAgICAgICAgICBkcmFnID0gZDMuYmVoYXZpb3IuZHJhZygpO1xuICAgICAgbGluZS5lbnRlcigpLmFwcGVuZCgnbGluZScpLmF0dHIoJ2lkJywgJ3N0cnVtLScgKyBpZCkuYXR0cignY2xhc3MnLCAnc3RydW0nKTtcbiAgICAgIGxpbmUuYXR0cigneDEnLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4gZC5wMVswXTtcbiAgICAgIH0pLmF0dHIoJ3kxJywgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuIGQucDFbMV07XG4gICAgICB9KS5hdHRyKCd4MicsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiBkLnAyWzBdO1xuICAgICAgfSkuYXR0cigneTInLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4gZC5wMlsxXTtcbiAgICAgIH0pLmF0dHIoJ3N0cm9rZScsICdibGFjaycpLmF0dHIoJ3N0cm9rZS13aWR0aCcsIDIpO1xuICAgICAgZHJhZy5vbignZHJhZycsIGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICAgIHZhciBldiA9IGQzLmV2ZW50O1xuICAgICAgICBpID0gaSArIDE7XG4gICAgICAgIHN0cnVtWydwJyArIGldWzBdID0gTWF0aC5taW4oTWF0aC5tYXgoc3RydW0ubWluWCArIDEsIGV2LngpLCBzdHJ1bS5tYXhYKTtcbiAgICAgICAgc3RydW1bJ3AnICsgaV1bMV0gPSBNYXRoLm1pbihNYXRoLm1heChzdHJ1bS5taW5ZLCBldi55KSwgc3RydW0ubWF4WSk7XG4gICAgICAgIGRyYXdTdHJ1bShzdHJ1bSwgaSAtIDEpO1xuICAgICAgfSkub24oJ2RyYWdlbmQnLCBvbkRyYWdFbmQoKSk7XG4gICAgICBjaXJjbGVzLmVudGVyKCkuYXBwZW5kKCdjaXJjbGUnKS5hdHRyKCdpZCcsICdzdHJ1bS0nICsgaWQpLmF0dHIoJ2NsYXNzJywgJ3N0cnVtJyk7XG4gICAgICBjaXJjbGVzLmF0dHIoJ2N4JywgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuIGRbMF07XG4gICAgICB9KS5hdHRyKCdjeScsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiBkWzFdO1xuICAgICAgfSkuYXR0cigncicsIDUpLnN0eWxlKCdvcGFjaXR5JywgZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgICAgcmV0dXJuIGFjdGl2ZVBvaW50ICE9PSB1bmRlZmluZWQgJiYgaSA9PT0gYWN0aXZlUG9pbnQgPyAwLjggOiAwO1xuICAgICAgfSkub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZDMuc2VsZWN0KHRoaXMpLnN0eWxlKCdvcGFjaXR5JywgMC44KTtcbiAgICAgIH0pLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZDMuc2VsZWN0KHRoaXMpLnN0eWxlKCdvcGFjaXR5JywgMCk7XG4gICAgICB9KS5jYWxsKGRyYWcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRpbWVuc2lvbnNGb3JQb2ludChwKSB7XG4gICAgICB2YXIgZGltcyA9IHtcbiAgICAgICAgaTogLTEsXG4gICAgICAgIGxlZnQ6IHVuZGVmaW5lZCxcbiAgICAgICAgcmlnaHQ6IHVuZGVmaW5lZFxuICAgICAgfTtcblxuICAgICAgX18uZGltZW5zaW9ucy5zb21lKGZ1bmN0aW9uIChkaW0sIGkpIHtcbiAgICAgICAgaWYgKHhzY2FsZShkaW0pIDwgcFswXSkge1xuICAgICAgICAgIHZhciBuZXh0ID0gX18uZGltZW5zaW9uc1tpICsgMV07XG4gICAgICAgICAgZGltcy5pID0gaTtcbiAgICAgICAgICBkaW1zLmxlZnQgPSBkaW07XG4gICAgICAgICAgZGltcy5yaWdodCA9IG5leHQ7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9KTtcblxuICAgICAgaWYgKGRpbXMubGVmdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIEV2ZW50IG9uIHRoZSBsZWZ0IHNpZGUgb2YgdGhlIGZpcnN0IGF4aXMuXG4gICAgICAgIGRpbXMuaSA9IDA7XG4gICAgICAgIGRpbXMubGVmdCA9IF9fLmRpbWVuc2lvbnNbMF07XG4gICAgICAgIGRpbXMucmlnaHQgPSBfXy5kaW1lbnNpb25zWzFdO1xuICAgICAgfSBlbHNlIGlmIChkaW1zLnJpZ2h0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gRXZlbnQgb24gdGhlIHJpZ2h0IHNpZGUgb2YgdGhlIGxhc3QgYXhpc1xuICAgICAgICBkaW1zLmkgPSBfXy5kaW1lbnNpb25zLmxlbmd0aCAtIDE7XG4gICAgICAgIGRpbXMucmlnaHQgPSBkaW1zLmxlZnQ7XG4gICAgICAgIGRpbXMubGVmdCA9IF9fLmRpbWVuc2lvbnNbX18uZGltZW5zaW9ucy5sZW5ndGggLSAyXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRpbXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25EcmFnU3RhcnQoKSB7XG4gICAgICAvLyBGaXJzdCB3ZSBuZWVkIHRvIGRldGVybWluZSBiZXR3ZWVuIHdoaWNoIHR3byBheGVzIHRoZSBzdHVybSB3YXMgc3RhcnRlZC5cbiAgICAgIC8vIFRoaXMgd2lsbCBkZXRlcm1pbmUgdGhlIGZyZWVkb20gb2YgbW92ZW1lbnQsIGJlY2F1c2UgYSBzdHJ1bSBjYW5cbiAgICAgIC8vIGxvZ2ljYWxseSBvbmx5IGhhcHBlbiBiZXR3ZWVuIHR3byBheGVzLCBzbyBubyBtb3ZlbWVudCBvdXRzaWRlIHRoZXNlIGF4ZXNcbiAgICAgIC8vIHNob3VsZCBiZSBhbGxvd2VkLlxuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHAgPSBkMy5tb3VzZShzdHJ1bVJlY3RbMF1bMF0pLFxuICAgICAgICAgICAgZGltcyxcbiAgICAgICAgICAgIHN0cnVtO1xuICAgICAgICBwWzBdID0gcFswXSAtIF9fLm1hcmdpbi5sZWZ0O1xuICAgICAgICBwWzFdID0gcFsxXSAtIF9fLm1hcmdpbi50b3A7XG4gICAgICAgIGRpbXMgPSBkaW1lbnNpb25zRm9yUG9pbnQocCksIHN0cnVtID0ge1xuICAgICAgICAgIHAxOiBwLFxuICAgICAgICAgIGRpbXM6IGRpbXMsXG4gICAgICAgICAgbWluWDogeHNjYWxlKGRpbXMubGVmdCksXG4gICAgICAgICAgbWF4WDogeHNjYWxlKGRpbXMucmlnaHQpLFxuICAgICAgICAgIG1pblk6IDAsXG4gICAgICAgICAgbWF4WTogaCgpXG4gICAgICAgIH07XG4gICAgICAgIHN0cnVtc1tkaW1zLmldID0gc3RydW07XG4gICAgICAgIHN0cnVtcy5hY3RpdmUgPSBkaW1zLmk7IC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBwb2ludCBpcyB3aXRoaW4gdGhlIGJvdW5kc1xuXG4gICAgICAgIHN0cnVtLnAxWzBdID0gTWF0aC5taW4oTWF0aC5tYXgoc3RydW0ubWluWCwgcFswXSksIHN0cnVtLm1heFgpO1xuICAgICAgICBzdHJ1bS5wMiA9IHN0cnVtLnAxLnNsaWNlKCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uRHJhZygpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBldiA9IGQzLmV2ZW50LFxuICAgICAgICAgICAgc3RydW0gPSBzdHJ1bXNbc3RydW1zLmFjdGl2ZV07IC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBwb2ludCBpcyB3aXRoaW4gdGhlIGJvdW5kc1xuXG4gICAgICAgIHN0cnVtLnAyWzBdID0gTWF0aC5taW4oTWF0aC5tYXgoc3RydW0ubWluWCArIDEsIGV2LnggLSBfXy5tYXJnaW4ubGVmdCksIHN0cnVtLm1heFgpO1xuICAgICAgICBzdHJ1bS5wMlsxXSA9IE1hdGgubWluKE1hdGgubWF4KHN0cnVtLm1pblksIGV2LnkgLSBfXy5tYXJnaW4udG9wKSwgc3RydW0ubWF4WSk7XG4gICAgICAgIGRyYXdTdHJ1bShzdHJ1bSwgMSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbnRhaW5tZW50VGVzdChzdHJ1bSwgd2lkdGgpIHtcbiAgICAgIHZhciBwMSA9IFtzdHJ1bS5wMVswXSAtIHN0cnVtLm1pblgsIHN0cnVtLnAxWzFdIC0gc3RydW0ubWluWF0sXG4gICAgICAgICAgcDIgPSBbc3RydW0ucDJbMF0gLSBzdHJ1bS5taW5YLCBzdHJ1bS5wMlsxXSAtIHN0cnVtLm1pblhdLFxuICAgICAgICAgIG0xID0gMSAtIHdpZHRoIC8gcDFbMF0sXG4gICAgICAgICAgYjEgPSBwMVsxXSAqICgxIC0gbTEpLFxuICAgICAgICAgIG0yID0gMSAtIHdpZHRoIC8gcDJbMF0sXG4gICAgICAgICAgYjIgPSBwMlsxXSAqICgxIC0gbTIpOyAvLyB0ZXN0IGlmIHBvaW50IGZhbGxzIGJldHdlZW4gbGluZXNcblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHZhciB4ID0gcFswXSxcbiAgICAgICAgICAgIHkgPSBwWzFdLFxuICAgICAgICAgICAgeTEgPSBtMSAqIHggKyBiMSxcbiAgICAgICAgICAgIHkyID0gbTIgKiB4ICsgYjI7XG5cbiAgICAgICAgaWYgKHkgPiBNYXRoLm1pbih5MSwgeTIpICYmIHkgPCBNYXRoLm1heCh5MSwgeTIpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNlbGVjdGVkKCkge1xuICAgICAgdmFyIGlkcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHN0cnVtcyksXG4gICAgICAgICAgYnJ1c2hlZCA9IF9fLmRhdGE7IC8vIEdldCB0aGUgaWRzIG9mIHRoZSBjdXJyZW50bHkgYWN0aXZlIHN0cnVtcy5cblxuICAgICAgaWRzID0gaWRzLmZpbHRlcihmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4gIWlzTmFOKGQpO1xuICAgICAgfSk7XG5cbiAgICAgIGZ1bmN0aW9uIGNyb3NzZXNTdHJ1bShkLCBpZCkge1xuICAgICAgICB2YXIgc3RydW0gPSBzdHJ1bXNbaWRdLFxuICAgICAgICAgICAgdGVzdCA9IGNvbnRhaW5tZW50VGVzdChzdHJ1bSwgc3RydW1zLndpZHRoKGlkKSksXG4gICAgICAgICAgICBkMSA9IHN0cnVtLmRpbXMubGVmdCxcbiAgICAgICAgICAgIGQyID0gc3RydW0uZGltcy5yaWdodCxcbiAgICAgICAgICAgIHkxID0geXNjYWxlW2QxXSxcbiAgICAgICAgICAgIHkyID0geXNjYWxlW2QyXSxcbiAgICAgICAgICAgIHBvaW50ID0gW3kxKGRbZDFdKSAtIHN0cnVtLm1pblgsIHkyKGRbZDJdKSAtIHN0cnVtLm1pblhdO1xuICAgICAgICByZXR1cm4gdGVzdChwb2ludCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBicnVzaGVkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYnJ1c2hlZC5maWx0ZXIoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgc3dpdGNoIChicnVzaC5wcmVkaWNhdGUpIHtcbiAgICAgICAgICBjYXNlICdBTkQnOlxuICAgICAgICAgICAgcmV0dXJuIGlkcy5ldmVyeShmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNyb3NzZXNTdHJ1bShkLCBpZCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNhc2UgJ09SJzpcbiAgICAgICAgICAgIHJldHVybiBpZHMuc29tZShmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNyb3NzZXNTdHJ1bShkLCBpZCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyAnVW5rbm93biBicnVzaCBwcmVkaWNhdGUgJyArIF9fLmJydXNoUHJlZGljYXRlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW1vdmVTdHJ1bSgpIHtcbiAgICAgIHZhciBzdHJ1bSA9IHN0cnVtc1tzdHJ1bXMuYWN0aXZlXSxcbiAgICAgICAgICBzdmcgPSBwYy5zZWxlY3Rpb24uc2VsZWN0KCdzdmcnKS5zZWxlY3QoJ2cjc3RydW1zJyk7XG4gICAgICBkZWxldGUgc3RydW1zW3N0cnVtcy5hY3RpdmVdO1xuICAgICAgc3RydW1zLmFjdGl2ZSA9IHVuZGVmaW5lZDtcbiAgICAgIHN2Zy5zZWxlY3RBbGwoJ2xpbmUjc3RydW0tJyArIHN0cnVtLmRpbXMuaSkucmVtb3ZlKCk7XG4gICAgICBzdmcuc2VsZWN0QWxsKCdjaXJjbGUjc3RydW0tJyArIHN0cnVtLmRpbXMuaSkucmVtb3ZlKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25EcmFnRW5kKCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGJydXNoZWQgPSBfXy5kYXRhLFxuICAgICAgICAgICAgc3RydW0gPSBzdHJ1bXNbc3RydW1zLmFjdGl2ZV07IC8vIE9rYXksIHNvbWV3aGF0IHVuZXhwZWN0ZWQsIGJ1dCBub3QgdG90YWxseSB1bnN1cnByaXNpbmcsIGEgbW91c2NsaWNrIGlzXG4gICAgICAgIC8vIGNvbnNpZGVyZWQgYSBkcmFnIHdpdGhvdXQgbW92ZS4gU28gd2UgaGF2ZSB0byBkZWFsIHdpdGggdGhhdCBjYXNlXG5cbiAgICAgICAgaWYgKHN0cnVtICYmIHN0cnVtLnAxWzBdID09PSBzdHJ1bS5wMlswXSAmJiBzdHJ1bS5wMVsxXSA9PT0gc3RydW0ucDJbMV0pIHtcbiAgICAgICAgICByZW1vdmVTdHJ1bShzdHJ1bXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJ1c2hlZCA9IHNlbGVjdGVkKHN0cnVtcyk7XG4gICAgICAgIHN0cnVtcy5hY3RpdmUgPSB1bmRlZmluZWQ7XG4gICAgICAgIF9fLmJydXNoZWQgPSBicnVzaGVkO1xuICAgICAgICBwYy5yZW5kZXJCcnVzaGVkKCk7XG4gICAgICAgIGV2ZW50cy5icnVzaGVuZC5jYWxsKHBjLCBfXy5icnVzaGVkKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYnJ1c2hSZXNldChzdHJ1bXMpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpZHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhzdHJ1bXMpLmZpbHRlcihmdW5jdGlvbiAoZCkge1xuICAgICAgICAgIHJldHVybiAhaXNOYU4oZCk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZHMuZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgIHN0cnVtcy5hY3RpdmUgPSBkO1xuICAgICAgICAgIHJlbW92ZVN0cnVtKHN0cnVtcyk7XG4gICAgICAgIH0pO1xuICAgICAgICBvbkRyYWdFbmQoc3RydW1zKSgpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsKCkge1xuICAgICAgdmFyIGRyYWcgPSBkMy5iZWhhdmlvci5kcmFnKCk7IC8vIE1hcCBvZiBjdXJyZW50IHN0cnVtcy4gU3RydW1zIGFyZSBzdG9yZWQgcGVyIHNlZ21lbnQgb2YgdGhlIFBDLiBBIHNlZ21lbnQsXG4gICAgICAvLyBiZWluZyB0aGUgYXJlYSBiZXR3ZWVuIHR3byBheGVzLiBUaGUgbGVmdCBtb3N0IGFyZWEgaXMgaW5kZXhlZCBhdCAwLlxuXG4gICAgICBzdHJ1bXMuYWN0aXZlID0gdW5kZWZpbmVkOyAvLyBSZXR1cm5zIHRoZSB3aWR0aCBvZiB0aGUgUEMgc2VnbWVudCB3aGVyZSBjdXJyZW50bHkgYSBzdHJ1bSBpcyBiZWluZ1xuICAgICAgLy8gcGxhY2VkLiBOT1RFOiBldmVuIHRob3VnaCB0aGV5IGFyZSBldmVubHkgc3BhY2VkIGluIG91ciBjdXJyZW50XG4gICAgICAvLyBpbXBsZW1lbnRhdGlvbiwgd2Uga2VlcCBmb3Igd2hlbiBub24tZXZlbiBzcGFjZWQgc2VnbWVudHMgYXJlIHN1cHBvcnRlZCBhc1xuICAgICAgLy8gd2VsbC5cblxuICAgICAgc3RydW1zLndpZHRoID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHZhciBzdHJ1bSA9IHN0cnVtc1tpZF07XG5cbiAgICAgICAgaWYgKHN0cnVtID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN0cnVtLm1heFggLSBzdHJ1bS5taW5YO1xuICAgICAgfTtcblxuICAgICAgcGMub24oJ2F4ZXNyZW9yZGVyLnN0cnVtcycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGlkcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHN0cnVtcykuZmlsdGVyKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgcmV0dXJuICFpc05hTihkKTtcbiAgICAgICAgfSk7IC8vIENoZWNrcyBpZiB0aGUgZmlyc3QgZGltZW5zaW9uIGlzIGRpcmVjdGx5IGxlZnQgb2YgdGhlIHNlY29uZCBkaW1lbnNpb24uXG5cbiAgICAgICAgZnVuY3Rpb24gY29uc2VjdXRpdmUoZmlyc3QsIHNlY29uZCkge1xuICAgICAgICAgIHZhciBsZW5ndGggPSBfXy5kaW1lbnNpb25zLmxlbmd0aDtcbiAgICAgICAgICByZXR1cm4gX18uZGltZW5zaW9ucy5zb21lKGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICAgICAgICByZXR1cm4gZCA9PT0gZmlyc3QgPyBpICsgaSA8IGxlbmd0aCAmJiBfXy5kaW1lbnNpb25zW2kgKyAxXSA9PT0gc2Vjb25kIDogZmFsc2U7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaWRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAvLyBXZSBoYXZlIHNvbWUgc3RydW1zLCB3aGljaCBtaWdodCBuZWVkIHRvIGJlIHJlbW92ZWQuXG4gICAgICAgICAgaWRzLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHZhciBkaW1zID0gc3RydW1zW2RdLmRpbXM7XG4gICAgICAgICAgICBzdHJ1bXMuYWN0aXZlID0gZDsgLy8gSWYgdGhlIHR3byBkaW1lbnNpb25zIG9mIHRoZSBjdXJyZW50IHN0cnVtIGFyZSBub3QgbmV4dCB0byBlYWNoIG90aGVyXG4gICAgICAgICAgICAvLyBhbnkgbW9yZSwgdGhhbiB3ZSdsbCBuZWVkIHRvIHJlbW92ZSB0aGUgc3RydW0uIE90aGVyd2lzZSB3ZSBrZWVwIGl0LlxuXG4gICAgICAgICAgICBpZiAoIWNvbnNlY3V0aXZlKGRpbXMubGVmdCwgZGltcy5yaWdodCkpIHtcbiAgICAgICAgICAgICAgcmVtb3ZlU3RydW0oc3RydW1zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBvbkRyYWdFbmQoc3RydW1zKSgpO1xuICAgICAgICB9XG4gICAgICB9KTsgLy8gQWRkIGEgbmV3IHN2ZyBncm91cCBpbiB3aGljaCB3ZSBkcmF3IHRoZSBzdHJ1bXMuXG5cbiAgICAgIHBjLnNlbGVjdGlvbi5zZWxlY3QoJ3N2ZycpLmFwcGVuZCgnZycpLmF0dHIoJ2lkJywgJ3N0cnVtcycpLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIF9fLm1hcmdpbi5sZWZ0ICsgJywnICsgX18ubWFyZ2luLnRvcCArICcpJyk7IC8vIEluc3RhbGwgdGhlIHJlcXVpcmVkIGJydXNoUmVzZXQgZnVuY3Rpb25cblxuICAgICAgcGMuYnJ1c2hSZXNldCA9IGJydXNoUmVzZXQoc3RydW1zKTtcbiAgICAgIGRyYWcub24oJ2RyYWdzdGFydCcsIG9uRHJhZ1N0YXJ0KHN0cnVtcykpLm9uKCdkcmFnJywgb25EcmFnKHN0cnVtcykpLm9uKCdkcmFnZW5kJywgb25EcmFnRW5kKHN0cnVtcykpOyAvLyBOT1RFOiBUaGUgc3R5bGluZyBuZWVkcyB0byBiZSBkb25lIGhlcmUgYW5kIG5vdCBpbiB0aGUgY3NzLiBUaGlzIGlzIGJlY2F1c2VcbiAgICAgIC8vICAgICAgIGZvciAxRCBicnVzaGluZywgdGhlIGNhbnZhcyBsYXllcnMgc2hvdWxkIG5vdCBsaXN0ZW4gdG9cbiAgICAgIC8vICAgICAgIHBvaW50ZXItZXZlbnRzLlxuXG4gICAgICBzdHJ1bVJlY3QgPSBwYy5zZWxlY3Rpb24uc2VsZWN0KCdzdmcnKS5pbnNlcnQoJ3JlY3QnLCAnZyNzdHJ1bXMnKS5hdHRyKCdpZCcsICdzdHJ1bS1ldmVudHMnKS5hdHRyKCd4JywgX18ubWFyZ2luLmxlZnQpLmF0dHIoJ3knLCBfXy5tYXJnaW4udG9wKS5hdHRyKCd3aWR0aCcsIHcoKSkuYXR0cignaGVpZ2h0JywgaCgpICsgMikuc3R5bGUoJ29wYWNpdHknLCAwKS5jYWxsKGRyYWcpO1xuICAgIH1cblxuICAgIGJydXNoLm1vZGVzWycyRC1zdHJ1bXMnXSA9IHtcbiAgICAgIGluc3RhbGw6IGluc3RhbGwsXG4gICAgICB1bmluc3RhbGw6IGZ1bmN0aW9uIHVuaW5zdGFsbCgpIHtcbiAgICAgICAgcGMuc2VsZWN0aW9uLnNlbGVjdCgnc3ZnJykuc2VsZWN0KCdnI3N0cnVtcycpLnJlbW92ZSgpO1xuICAgICAgICBwYy5zZWxlY3Rpb24uc2VsZWN0KCdzdmcnKS5zZWxlY3QoJ3JlY3Qjc3RydW0tZXZlbnRzJykucmVtb3ZlKCk7XG4gICAgICAgIHBjLm9uKCdheGVzcmVvcmRlci5zdHJ1bXMnLCB1bmRlZmluZWQpO1xuICAgICAgICBkZWxldGUgcGMuYnJ1c2hSZXNldDtcbiAgICAgICAgc3RydW1SZWN0ID0gdW5kZWZpbmVkO1xuICAgICAgfSxcbiAgICAgIHNlbGVjdGVkOiBzZWxlY3RlZCxcbiAgICAgIGJydXNoU3RhdGU6IGZ1bmN0aW9uIGJydXNoU3RhdGUoKSB7XG4gICAgICAgIHJldHVybiBzdHJ1bXM7XG4gICAgICB9XG4gICAgfTtcbiAgfSkoKTsgLy8gYnJ1c2ggbW9kZTogMUQtQXhlcyB3aXRoIG11bHRpcGxlIGV4dGVudHNcbiAgLy8gcmVxdWlyZXMgZDMuc3ZnLm11bHRpYnJ1c2hcblxuXG4gIChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHR5cGVvZiBkMy5zdmcubXVsdGlicnVzaCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBicnVzaGVzID0ge307XG5cbiAgICBmdW5jdGlvbiBpc19icnVzaGVkKHApIHtcbiAgICAgIHJldHVybiAhYnJ1c2hlc1twXS5lbXB0eSgpO1xuICAgIH0gLy8gZGF0YSB3aXRoaW4gZXh0ZW50c1xuXG5cbiAgICBmdW5jdGlvbiBzZWxlY3RlZCgpIHtcbiAgICAgIHZhciBhY3RpdmVzID0gX18uZGltZW5zaW9ucy5maWx0ZXIoaXNfYnJ1c2hlZCksXG4gICAgICAgICAgZXh0ZW50cyA9IGFjdGl2ZXMubWFwKGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHJldHVybiBicnVzaGVzW3BdLmV4dGVudCgpO1xuICAgICAgfSk7IC8vIFdlIGRvbid0IHdhbnQgdG8gcmV0dXJuIHRoZSBmdWxsIGRhdGEgc2V0IHdoZW4gdGhlcmUgYXJlIG5vIGF4ZXMgYnJ1c2hlZC5cbiAgICAgIC8vIEFjdHVhbGx5LCB3aGVuIHRoZXJlIGFyZSBubyBheGVzIGJydXNoZWQsIGJ5IGRlZmluaXRpb24sIG5vIGl0ZW1zIGFyZVxuICAgICAgLy8gc2VsZWN0ZWQuIFNvLCBsZXQncyBhdm9pZCB0aGUgZmlsdGVyaW5nIGFuZCBqdXN0IHJldHVybiBmYWxzZS5cbiAgICAgIC8vaWYgKGFjdGl2ZXMubGVuZ3RoID09PSAwKSByZXR1cm4gZmFsc2U7XG4gICAgICAvLyBSZXNvbHZlcyBicm9rZW4gZXhhbXBsZXMgZm9yIG5vdy4gVGhleSBleHBlY3QgdG8gZ2V0IHRoZSBmdWxsIGRhdGFzZXQgYmFjayBmcm9tIGVtcHR5IGJydXNoZXNcblxuXG4gICAgICBpZiAoYWN0aXZlcy5sZW5ndGggPT09IDApIHJldHVybiBfXy5kYXRhOyAvLyB0ZXN0IGlmIHdpdGhpbiByYW5nZVxuXG4gICAgICB2YXIgd2l0aGluID0ge1xuICAgICAgICBkYXRlOiBmdW5jdGlvbiBkYXRlKGQsIHAsIGRpbWVuc2lvbiwgYikge1xuICAgICAgICAgIGlmICh0eXBlb2YgeXNjYWxlW3BdLnJhbmdlUG9pbnRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAvLyBpZiBpdCBpcyBvcmRpbmFsXG4gICAgICAgICAgICByZXR1cm4gYlswXSA8PSB5c2NhbGVbcF0oZFtwXSkgJiYgeXNjYWxlW3BdKGRbcF0pIDw9IGJbMV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBiWzBdIDw9IGRbcF0gJiYgZFtwXSA8PSBiWzFdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbnVtYmVyOiBmdW5jdGlvbiBudW1iZXIoZCwgcCwgZGltZW5zaW9uLCBiKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB5c2NhbGVbcF0ucmFuZ2VQb2ludHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vIGlmIGl0IGlzIG9yZGluYWxcbiAgICAgICAgICAgIHJldHVybiBiWzBdIDw9IHlzY2FsZVtwXShkW3BdKSAmJiB5c2NhbGVbcF0oZFtwXSkgPD0gYlsxXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGJbMF0gPD0gZFtwXSAmJiBkW3BdIDw9IGJbMV07XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzdHJpbmc6IGZ1bmN0aW9uIHN0cmluZyhkLCBwLCBkaW1lbnNpb24sIGIpIHtcbiAgICAgICAgICByZXR1cm4gYlswXSA8PSB5c2NhbGVbcF0oZFtwXSkgJiYgeXNjYWxlW3BdKGRbcF0pIDw9IGJbMV07XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZXR1cm4gX18uZGF0YS5maWx0ZXIoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgc3dpdGNoIChicnVzaC5wcmVkaWNhdGUpIHtcbiAgICAgICAgICBjYXNlICdBTkQnOlxuICAgICAgICAgICAgcmV0dXJuIGFjdGl2ZXMuZXZlcnkoZnVuY3Rpb24gKHAsIGRpbWVuc2lvbikge1xuICAgICAgICAgICAgICByZXR1cm4gZXh0ZW50c1tkaW1lbnNpb25dLnNvbWUoZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gd2l0aGluW19fLnR5cGVzW3BdXShkLCBwLCBkaW1lbnNpb24sIGIpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY2FzZSAnT1InOlxuICAgICAgICAgICAgcmV0dXJuIGFjdGl2ZXMuc29tZShmdW5jdGlvbiAocCwgZGltZW5zaW9uKSB7XG4gICAgICAgICAgICAgIHJldHVybiBleHRlbnRzW2RpbWVuc2lvbl0uc29tZShmdW5jdGlvbiAoYikge1xuICAgICAgICAgICAgICAgIHJldHVybiB3aXRoaW5bX18udHlwZXNbcF1dKGQsIHAsIGRpbWVuc2lvbiwgYik7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgJ1Vua25vd24gYnJ1c2ggcHJlZGljYXRlICcgKyBfXy5icnVzaFByZWRpY2F0ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYnJ1c2hFeHRlbnRzKCkge1xuICAgICAgdmFyIGV4dGVudHMgPSB7fTtcblxuICAgICAgX18uZGltZW5zaW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHZhciBicnVzaCA9IGJydXNoZXNbZF07XG5cbiAgICAgICAgaWYgKGJydXNoICE9PSB1bmRlZmluZWQgJiYgIWJydXNoLmVtcHR5KCkpIHtcbiAgICAgICAgICB2YXIgZXh0ZW50ID0gYnJ1c2guZXh0ZW50KCk7XG4gICAgICAgICAgZXh0ZW50c1tkXSA9IGV4dGVudDtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBleHRlbnRzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJydXNoRm9yKGF4aXMpIHtcbiAgICAgIHZhciBicnVzaCA9IGQzLnN2Zy5tdWx0aWJydXNoKCk7XG4gICAgICBicnVzaC55KHlzY2FsZVtheGlzXSkub24oJ2JydXNoc3RhcnQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChkMy5ldmVudC5zb3VyY2VFdmVudCAhPT0gbnVsbCkge1xuICAgICAgICAgIGQzLmV2ZW50LnNvdXJjZUV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB9XG4gICAgICB9KS5vbignYnJ1c2gnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGJydXNoVXBkYXRlZChzZWxlY3RlZCgpKTtcbiAgICAgIH0pLm9uKCdicnVzaGVuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gZDMuc3ZnLm11bHRpYnJ1c2ggY2xlYXJzIGV4dGVudHMganVzdCBiZWZvcmUgY2FsbGluZyAnYnJ1c2hlbmQnXG4gICAgICAgIC8vIHNvIHdlIGhhdmUgdG8gdXBkYXRlIGhlcmUgYWdhaW4uXG4gICAgICAgIC8vIFRoaXMgZml4ZXMgaXNzdWUgIzEwMyBmb3Igbm93LCBidXQgc2hvdWxkIGJlIGNoYW5nZWQgaW4gZDMuc3ZnLm11bHRpYnJ1c2hcbiAgICAgICAgLy8gdG8gYXZvaWQgdW5uZWNlc3NhcnkgY29tcHV0YXRpb24uXG4gICAgICAgIGJydXNoVXBkYXRlZChzZWxlY3RlZCgpKTtcbiAgICAgICAgZXZlbnRzLmJydXNoZW5kLmNhbGwocGMsIF9fLmJydXNoZWQpO1xuICAgICAgfSkuZXh0ZW50QWRhcHRpb24oZnVuY3Rpb24gKHNlbGVjdGlvbikge1xuICAgICAgICBzZWxlY3Rpb24uc3R5bGUoJ3Zpc2liaWxpdHknLCBudWxsKS5hdHRyKCd4JywgLTE1KS5hdHRyKCd3aWR0aCcsIDMwKTtcbiAgICAgIH0pLnJlc2l6ZUFkYXB0aW9uKGZ1bmN0aW9uIChzZWxlY3Rpb24pIHtcbiAgICAgICAgc2VsZWN0aW9uLnNlbGVjdEFsbCgncmVjdCcpLmF0dHIoJ3gnLCAtMTUpLmF0dHIoJ3dpZHRoJywgMzApO1xuICAgICAgfSk7XG4gICAgICBicnVzaGVzW2F4aXNdID0gYnJ1c2g7XG4gICAgICByZXR1cm4gYnJ1c2g7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYnJ1c2hSZXNldChkaW1lbnNpb24pIHtcbiAgICAgIF9fLmJydXNoZWQgPSBmYWxzZTtcblxuICAgICAgaWYgKGcpIHtcbiAgICAgICAgZy5zZWxlY3RBbGwoJy5icnVzaCcpLmVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICBkMy5zZWxlY3QodGhpcykuY2FsbChicnVzaGVzW2RdLmNsZWFyKCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcGMucmVuZGVyQnJ1c2hlZCgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsKCkge1xuICAgICAgaWYgKCFnKSBwYy5jcmVhdGVBeGVzKCk7IC8vIEFkZCBhbmQgc3RvcmUgYSBicnVzaCBmb3IgZWFjaCBheGlzLlxuXG4gICAgICBnLmFwcGVuZCgnc3ZnOmcnKS5hdHRyKCdjbGFzcycsICdicnVzaCcpLmVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgZDMuc2VsZWN0KHRoaXMpLmNhbGwoYnJ1c2hGb3IoZCkpO1xuICAgICAgfSkuc2VsZWN0QWxsKCdyZWN0Jykuc3R5bGUoJ3Zpc2liaWxpdHknLCBudWxsKS5hdHRyKCd4JywgLTE1KS5hdHRyKCd3aWR0aCcsIDMwKTtcbiAgICAgIHBjLmJydXNoRXh0ZW50cyA9IGJydXNoRXh0ZW50cztcbiAgICAgIHBjLmJydXNoUmVzZXQgPSBicnVzaFJlc2V0O1xuICAgICAgcmV0dXJuIHBjO1xuICAgIH1cblxuICAgIGJydXNoLm1vZGVzWycxRC1heGVzLW11bHRpJ10gPSB7XG4gICAgICBpbnN0YWxsOiBpbnN0YWxsLFxuICAgICAgdW5pbnN0YWxsOiBmdW5jdGlvbiB1bmluc3RhbGwoKSB7XG4gICAgICAgIGcuc2VsZWN0QWxsKCcuYnJ1c2gnKS5yZW1vdmUoKTtcbiAgICAgICAgYnJ1c2hlcyA9IHt9O1xuICAgICAgICBkZWxldGUgcGMuYnJ1c2hFeHRlbnRzO1xuICAgICAgICBkZWxldGUgcGMuYnJ1c2hSZXNldDtcbiAgICAgIH0sXG4gICAgICBzZWxlY3RlZDogc2VsZWN0ZWQsXG4gICAgICBicnVzaFN0YXRlOiBicnVzaEV4dGVudHNcbiAgICB9O1xuICB9KSgpOyAvLyBicnVzaCBtb2RlOiBhbmd1bGFyXG4gIC8vIGNvZGUgYmFzZWQgb24gMkQuc3RydW1zLmpzXG5cblxuICAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcmNzID0ge30sXG4gICAgICAgIHN0cnVtUmVjdDtcblxuICAgIGZ1bmN0aW9uIGRyYXdTdHJ1bShhcmMsIGFjdGl2ZVBvaW50KSB7XG4gICAgICB2YXIgc3ZnID0gcGMuc2VsZWN0aW9uLnNlbGVjdCgnc3ZnJykuc2VsZWN0KCdnI2FyY3MnKSxcbiAgICAgICAgICBpZCA9IGFyYy5kaW1zLmksXG4gICAgICAgICAgcG9pbnRzID0gW2FyYy5wMiwgYXJjLnAzXSxcbiAgICAgICAgICBsaW5lID0gc3ZnLnNlbGVjdEFsbCgnbGluZSNhcmMtJyArIGlkKS5kYXRhKFt7XG4gICAgICAgIHAxOiBhcmMucDEsXG4gICAgICAgIHAyOiBhcmMucDJcbiAgICAgIH0sIHtcbiAgICAgICAgcDE6IGFyYy5wMSxcbiAgICAgICAgcDI6IGFyYy5wM1xuICAgICAgfV0pLFxuICAgICAgICAgIGNpcmNsZXMgPSBzdmcuc2VsZWN0QWxsKCdjaXJjbGUjYXJjLScgKyBpZCkuZGF0YShwb2ludHMpLFxuICAgICAgICAgIGRyYWcgPSBkMy5iZWhhdmlvci5kcmFnKCksXG4gICAgICAgICAgcGF0aCA9IHN2Zy5zZWxlY3RBbGwoJ3BhdGgjYXJjLScgKyBpZCkuZGF0YShbYXJjXSk7XG4gICAgICBwYXRoLmVudGVyKCkuYXBwZW5kKCdwYXRoJykuYXR0cignaWQnLCAnYXJjLScgKyBpZCkuYXR0cignY2xhc3MnLCAnYXJjJykuc3R5bGUoJ2ZpbGwnLCAnb3JhbmdlJykuc3R5bGUoJ29wYWNpdHknLCAwLjUpO1xuICAgICAgcGF0aC5hdHRyKCdkJywgYXJjLmFyYykuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgYXJjLnAxWzBdICsgJywnICsgYXJjLnAxWzFdICsgJyknKTtcbiAgICAgIGxpbmUuZW50ZXIoKS5hcHBlbmQoJ2xpbmUnKS5hdHRyKCdpZCcsICdhcmMtJyArIGlkKS5hdHRyKCdjbGFzcycsICdhcmMnKTtcbiAgICAgIGxpbmUuYXR0cigneDEnLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4gZC5wMVswXTtcbiAgICAgIH0pLmF0dHIoJ3kxJywgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuIGQucDFbMV07XG4gICAgICB9KS5hdHRyKCd4MicsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiBkLnAyWzBdO1xuICAgICAgfSkuYXR0cigneTInLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4gZC5wMlsxXTtcbiAgICAgIH0pLmF0dHIoJ3N0cm9rZScsICdibGFjaycpLmF0dHIoJ3N0cm9rZS13aWR0aCcsIDIpO1xuICAgICAgZHJhZy5vbignZHJhZycsIGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICAgIHZhciBldiA9IGQzLmV2ZW50LFxuICAgICAgICAgICAgYW5nbGUgPSAwO1xuICAgICAgICBpID0gaSArIDI7XG4gICAgICAgIGFyY1sncCcgKyBpXVswXSA9IE1hdGgubWluKE1hdGgubWF4KGFyYy5taW5YICsgMSwgZXYueCksIGFyYy5tYXhYKTtcbiAgICAgICAgYXJjWydwJyArIGldWzFdID0gTWF0aC5taW4oTWF0aC5tYXgoYXJjLm1pblksIGV2LnkpLCBhcmMubWF4WSk7XG4gICAgICAgIGFuZ2xlID0gaSA9PT0gMyA/IGFyY3Muc3RhcnRBbmdsZShpZCkgOiBhcmNzLmVuZEFuZ2xlKGlkKTtcblxuICAgICAgICBpZiAoYXJjLnN0YXJ0QW5nbGUgPCBNYXRoLlBJICYmIGFyYy5lbmRBbmdsZSA8IE1hdGguUEkgJiYgYW5nbGUgPCBNYXRoLlBJIHx8IGFyYy5zdGFydEFuZ2xlID49IE1hdGguUEkgJiYgYXJjLmVuZEFuZ2xlID49IE1hdGguUEkgJiYgYW5nbGUgPj0gTWF0aC5QSSkge1xuICAgICAgICAgIGlmIChpID09PSAyKSB7XG4gICAgICAgICAgICBhcmMuZW5kQW5nbGUgPSBhbmdsZTtcbiAgICAgICAgICAgIGFyYy5hcmMuZW5kQW5nbGUoYW5nbGUpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaSA9PT0gMykge1xuICAgICAgICAgICAgYXJjLnN0YXJ0QW5nbGUgPSBhbmdsZTtcbiAgICAgICAgICAgIGFyYy5hcmMuc3RhcnRBbmdsZShhbmdsZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZHJhd1N0cnVtKGFyYywgaSAtIDIpO1xuICAgICAgfSkub24oJ2RyYWdlbmQnLCBvbkRyYWdFbmQoKSk7XG4gICAgICBjaXJjbGVzLmVudGVyKCkuYXBwZW5kKCdjaXJjbGUnKS5hdHRyKCdpZCcsICdhcmMtJyArIGlkKS5hdHRyKCdjbGFzcycsICdhcmMnKTtcbiAgICAgIGNpcmNsZXMuYXR0cignY3gnLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4gZFswXTtcbiAgICAgIH0pLmF0dHIoJ2N5JywgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuIGRbMV07XG4gICAgICB9KS5hdHRyKCdyJywgNSkuc3R5bGUoJ29wYWNpdHknLCBmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICByZXR1cm4gYWN0aXZlUG9pbnQgIT09IHVuZGVmaW5lZCAmJiBpID09PSBhY3RpdmVQb2ludCA/IDAuOCA6IDA7XG4gICAgICB9KS5vbignbW91c2VvdmVyJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBkMy5zZWxlY3QodGhpcykuc3R5bGUoJ29wYWNpdHknLCAwLjgpO1xuICAgICAgfSkub24oJ21vdXNlb3V0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICBkMy5zZWxlY3QodGhpcykuc3R5bGUoJ29wYWNpdHknLCAwKTtcbiAgICAgIH0pLmNhbGwoZHJhZyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGltZW5zaW9uc0ZvclBvaW50KHApIHtcbiAgICAgIHZhciBkaW1zID0ge1xuICAgICAgICBpOiAtMSxcbiAgICAgICAgbGVmdDogdW5kZWZpbmVkLFxuICAgICAgICByaWdodDogdW5kZWZpbmVkXG4gICAgICB9O1xuXG4gICAgICBfXy5kaW1lbnNpb25zLnNvbWUoZnVuY3Rpb24gKGRpbSwgaSkge1xuICAgICAgICBpZiAoeHNjYWxlKGRpbSkgPCBwWzBdKSB7XG4gICAgICAgICAgdmFyIG5leHQgPSBfXy5kaW1lbnNpb25zW2kgKyAxXTtcbiAgICAgICAgICBkaW1zLmkgPSBpO1xuICAgICAgICAgIGRpbXMubGVmdCA9IGRpbTtcbiAgICAgICAgICBkaW1zLnJpZ2h0ID0gbmV4dDtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoZGltcy5sZWZ0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gRXZlbnQgb24gdGhlIGxlZnQgc2lkZSBvZiB0aGUgZmlyc3QgYXhpcy5cbiAgICAgICAgZGltcy5pID0gMDtcbiAgICAgICAgZGltcy5sZWZ0ID0gX18uZGltZW5zaW9uc1swXTtcbiAgICAgICAgZGltcy5yaWdodCA9IF9fLmRpbWVuc2lvbnNbMV07XG4gICAgICB9IGVsc2UgaWYgKGRpbXMucmlnaHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBFdmVudCBvbiB0aGUgcmlnaHQgc2lkZSBvZiB0aGUgbGFzdCBheGlzXG4gICAgICAgIGRpbXMuaSA9IF9fLmRpbWVuc2lvbnMubGVuZ3RoIC0gMTtcbiAgICAgICAgZGltcy5yaWdodCA9IGRpbXMubGVmdDtcbiAgICAgICAgZGltcy5sZWZ0ID0gX18uZGltZW5zaW9uc1tfXy5kaW1lbnNpb25zLmxlbmd0aCAtIDJdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGltcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbkRyYWdTdGFydCgpIHtcbiAgICAgIC8vIEZpcnN0IHdlIG5lZWQgdG8gZGV0ZXJtaW5lIGJldHdlZW4gd2hpY2ggdHdvIGF4ZXMgdGhlIGFyYyB3YXMgc3RhcnRlZC5cbiAgICAgIC8vIFRoaXMgd2lsbCBkZXRlcm1pbmUgdGhlIGZyZWVkb20gb2YgbW92ZW1lbnQsIGJlY2F1c2UgYSBhcmMgY2FuXG4gICAgICAvLyBsb2dpY2FsbHkgb25seSBoYXBwZW4gYmV0d2VlbiB0d28gYXhlcywgc28gbm8gbW92ZW1lbnQgb3V0c2lkZSB0aGVzZSBheGVzXG4gICAgICAvLyBzaG91bGQgYmUgYWxsb3dlZC5cbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwID0gZDMubW91c2Uoc3RydW1SZWN0WzBdWzBdKSxcbiAgICAgICAgICAgIGRpbXMsXG4gICAgICAgICAgICBhcmM7XG4gICAgICAgIHBbMF0gPSBwWzBdIC0gX18ubWFyZ2luLmxlZnQ7XG4gICAgICAgIHBbMV0gPSBwWzFdIC0gX18ubWFyZ2luLnRvcDtcbiAgICAgICAgZGltcyA9IGRpbWVuc2lvbnNGb3JQb2ludChwKSwgYXJjID0ge1xuICAgICAgICAgIHAxOiBwLFxuICAgICAgICAgIGRpbXM6IGRpbXMsXG4gICAgICAgICAgbWluWDogeHNjYWxlKGRpbXMubGVmdCksXG4gICAgICAgICAgbWF4WDogeHNjYWxlKGRpbXMucmlnaHQpLFxuICAgICAgICAgIG1pblk6IDAsXG4gICAgICAgICAgbWF4WTogaCgpLFxuICAgICAgICAgIHN0YXJ0QW5nbGU6IHVuZGVmaW5lZCxcbiAgICAgICAgICBlbmRBbmdsZTogdW5kZWZpbmVkLFxuICAgICAgICAgIGFyYzogZDMuc3ZnLmFyYygpLmlubmVyUmFkaXVzKDApXG4gICAgICAgIH07XG4gICAgICAgIGFyY3NbZGltcy5pXSA9IGFyYztcbiAgICAgICAgYXJjcy5hY3RpdmUgPSBkaW1zLmk7IC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBwb2ludCBpcyB3aXRoaW4gdGhlIGJvdW5kc1xuXG4gICAgICAgIGFyYy5wMVswXSA9IE1hdGgubWluKE1hdGgubWF4KGFyYy5taW5YLCBwWzBdKSwgYXJjLm1heFgpO1xuICAgICAgICBhcmMucDIgPSBhcmMucDEuc2xpY2UoKTtcbiAgICAgICAgYXJjLnAzID0gYXJjLnAxLnNsaWNlKCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uRHJhZygpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBldiA9IGQzLmV2ZW50LFxuICAgICAgICAgICAgYXJjID0gYXJjc1thcmNzLmFjdGl2ZV07IC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBwb2ludCBpcyB3aXRoaW4gdGhlIGJvdW5kc1xuXG4gICAgICAgIGFyYy5wMlswXSA9IE1hdGgubWluKE1hdGgubWF4KGFyYy5taW5YICsgMSwgZXYueCAtIF9fLm1hcmdpbi5sZWZ0KSwgYXJjLm1heFgpO1xuICAgICAgICBhcmMucDJbMV0gPSBNYXRoLm1pbihNYXRoLm1heChhcmMubWluWSwgZXYueSAtIF9fLm1hcmdpbi50b3ApLCBhcmMubWF4WSk7XG4gICAgICAgIGFyYy5wMyA9IGFyYy5wMi5zbGljZSgpO1xuICAgICAgICBkcmF3U3RydW0oYXJjLCAxKTtcbiAgICAgIH07XG4gICAgfSAvLyBzb21lIGhlbHBlciBmdW5jdGlvbnNcblxuXG4gICAgZnVuY3Rpb24gaHlwb3RoZW51c2UoYSwgYikge1xuICAgICAgcmV0dXJuIE1hdGguc3FydChhICogYSArIGIgKiBiKTtcbiAgICB9XG5cbiAgICB2YXIgcmFkID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGMgPSBNYXRoLlBJIC8gMTgwO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhbmdsZSkge1xuICAgICAgICByZXR1cm4gYW5nbGUgKiBjO1xuICAgICAgfTtcbiAgICB9KCk7XG5cbiAgICB2YXIgZGVnID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGMgPSAxODAgLyBNYXRoLlBJO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhbmdsZSkge1xuICAgICAgICByZXR1cm4gYW5nbGUgKiBjO1xuICAgICAgfTtcbiAgICB9KCk7IC8vIFswLCAyKlBJXSAtPiBbLVBJLzIsIFBJLzJdXG5cblxuICAgIHZhciBzaWduZWRBbmdsZSA9IGZ1bmN0aW9uIHNpZ25lZEFuZ2xlKGFuZ2xlKSB7XG4gICAgICB2YXIgcmV0ID0gYW5nbGU7XG5cbiAgICAgIGlmIChhbmdsZSA+IE1hdGguUEkpIHtcbiAgICAgICAgcmV0ID0gYW5nbGUgLSAxLjUgKiBNYXRoLlBJO1xuICAgICAgICByZXQgPSBhbmdsZSAtIDEuNSAqIE1hdGguUEk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXQgPSBhbmdsZSAtIDAuNSAqIE1hdGguUEk7XG4gICAgICAgIHJldCA9IGFuZ2xlIC0gMC41ICogTWF0aC5QSTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIC1yZXQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBhbmdsZXMgYXJlIHN0b3JlZCBpbiByYWRpYW5zIGZyb20gaW4gWzAsIDIqUEldLCB3aGVyZSAwIGluIDEyIG8nY2xvY2suXG4gICAgICogSG93ZXZlciwgb25lIGNhbiBvbmx5IHNlbGVjdCBsaW5lcyBmcm9tIDAgdG8gUEksIHNvIHdlIGNvbXB1dGUgdGhlXG4gICAgICogJ3NpZ25lZCcgYW5nbGUsIHdoZXJlIDAgaXMgdGhlIGhvcml6b250YWwgbGluZSAoMyBvJ2Nsb2NrKSwgYW5kICsvLSBQSS8yXG4gICAgICogYXJlIDEyIGFuZCA2IG8nY2xvY2sgcmVzcGVjdGl2ZWx5LlxuICAgICAqL1xuXG5cbiAgICBmdW5jdGlvbiBjb250YWlubWVudFRlc3QoYXJjKSB7XG4gICAgICB2YXIgc3RhcnRBbmdsZSA9IHNpZ25lZEFuZ2xlKGFyYy5zdGFydEFuZ2xlKTtcbiAgICAgIHZhciBlbmRBbmdsZSA9IHNpZ25lZEFuZ2xlKGFyYy5lbmRBbmdsZSk7XG5cbiAgICAgIGlmIChzdGFydEFuZ2xlID4gZW5kQW5nbGUpIHtcbiAgICAgICAgdmFyIHRtcCA9IHN0YXJ0QW5nbGU7XG4gICAgICAgIHN0YXJ0QW5nbGUgPSBlbmRBbmdsZTtcbiAgICAgICAgZW5kQW5nbGUgPSB0bXA7XG4gICAgICB9IC8vIHRlc3QgaWYgc2VnbWVudCBhbmdsZSBpcyBjb250YWluZWQgaW4gYW5nbGUgaW50ZXJ2YWxcblxuXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgaWYgKGEgPj0gc3RhcnRBbmdsZSAmJiBhIDw9IGVuZEFuZ2xlKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNlbGVjdGVkKCkge1xuICAgICAgdmFyIGlkcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGFyY3MpLFxuICAgICAgICAgIGJydXNoZWQgPSBfXy5kYXRhOyAvLyBHZXQgdGhlIGlkcyBvZiB0aGUgY3VycmVudGx5IGFjdGl2ZSBhcmNzLlxuXG4gICAgICBpZHMgPSBpZHMuZmlsdGVyKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiAhaXNOYU4oZCk7XG4gICAgICB9KTtcblxuICAgICAgZnVuY3Rpb24gY3Jvc3Nlc1N0cnVtKGQsIGlkKSB7XG4gICAgICAgIHZhciBhcmMgPSBhcmNzW2lkXSxcbiAgICAgICAgICAgIHRlc3QgPSBjb250YWlubWVudFRlc3QoYXJjKSxcbiAgICAgICAgICAgIGQxID0gYXJjLmRpbXMubGVmdCxcbiAgICAgICAgICAgIGQyID0gYXJjLmRpbXMucmlnaHQsXG4gICAgICAgICAgICB5MSA9IHlzY2FsZVtkMV0sXG4gICAgICAgICAgICB5MiA9IHlzY2FsZVtkMl0sXG4gICAgICAgICAgICBhID0gYXJjcy53aWR0aChpZCksXG4gICAgICAgICAgICBiID0geTEoZFtkMV0pIC0geTIoZFtkMl0pLFxuICAgICAgICAgICAgYyA9IGh5cG90aGVudXNlKGEsIGIpLFxuICAgICAgICAgICAgYW5nbGUgPSBNYXRoLmFzaW4oYiAvIGMpOyAvLyByYWQgaW4gWy1QSS8yLCBQSS8yXVxuXG4gICAgICAgIHJldHVybiB0ZXN0KGFuZ2xlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlkcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGJydXNoZWQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBicnVzaGVkLmZpbHRlcihmdW5jdGlvbiAoZCkge1xuICAgICAgICBzd2l0Y2ggKGJydXNoLnByZWRpY2F0ZSkge1xuICAgICAgICAgIGNhc2UgJ0FORCc6XG4gICAgICAgICAgICByZXR1cm4gaWRzLmV2ZXJ5KGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAgICAgICByZXR1cm4gY3Jvc3Nlc1N0cnVtKGQsIGlkKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY2FzZSAnT1InOlxuICAgICAgICAgICAgcmV0dXJuIGlkcy5zb21lKGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAgICAgICByZXR1cm4gY3Jvc3Nlc1N0cnVtKGQsIGlkKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93ICdVbmtub3duIGJydXNoIHByZWRpY2F0ZSAnICsgX18uYnJ1c2hQcmVkaWNhdGU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbW92ZVN0cnVtKCkge1xuICAgICAgdmFyIGFyYyA9IGFyY3NbYXJjcy5hY3RpdmVdLFxuICAgICAgICAgIHN2ZyA9IHBjLnNlbGVjdGlvbi5zZWxlY3QoJ3N2ZycpLnNlbGVjdCgnZyNhcmNzJyk7XG4gICAgICBkZWxldGUgYXJjc1thcmNzLmFjdGl2ZV07XG4gICAgICBhcmNzLmFjdGl2ZSA9IHVuZGVmaW5lZDtcbiAgICAgIHN2Zy5zZWxlY3RBbGwoJ2xpbmUjYXJjLScgKyBhcmMuZGltcy5pKS5yZW1vdmUoKTtcbiAgICAgIHN2Zy5zZWxlY3RBbGwoJ2NpcmNsZSNhcmMtJyArIGFyYy5kaW1zLmkpLnJlbW92ZSgpO1xuICAgICAgc3ZnLnNlbGVjdEFsbCgncGF0aCNhcmMtJyArIGFyYy5kaW1zLmkpLnJlbW92ZSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uRHJhZ0VuZCgpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBicnVzaGVkID0gX18uZGF0YSxcbiAgICAgICAgICAgIGFyYyA9IGFyY3NbYXJjcy5hY3RpdmVdOyAvLyBPa2F5LCBzb21ld2hhdCB1bmV4cGVjdGVkLCBidXQgbm90IHRvdGFsbHkgdW5zdXJwcmlzaW5nLCBhIG1vdXNjbGljayBpc1xuICAgICAgICAvLyBjb25zaWRlcmVkIGEgZHJhZyB3aXRob3V0IG1vdmUuIFNvIHdlIGhhdmUgdG8gZGVhbCB3aXRoIHRoYXQgY2FzZVxuXG4gICAgICAgIGlmIChhcmMgJiYgYXJjLnAxWzBdID09PSBhcmMucDJbMF0gJiYgYXJjLnAxWzFdID09PSBhcmMucDJbMV0pIHtcbiAgICAgICAgICByZW1vdmVTdHJ1bShhcmNzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhcmMpIHtcbiAgICAgICAgICB2YXIgYW5nbGUgPSBhcmNzLnN0YXJ0QW5nbGUoYXJjcy5hY3RpdmUpO1xuICAgICAgICAgIGFyYy5zdGFydEFuZ2xlID0gYW5nbGU7XG4gICAgICAgICAgYXJjLmVuZEFuZ2xlID0gYW5nbGU7XG4gICAgICAgICAgYXJjLmFyYy5vdXRlclJhZGl1cyhhcmNzLmxlbmd0aChhcmNzLmFjdGl2ZSkpLnN0YXJ0QW5nbGUoYW5nbGUpLmVuZEFuZ2xlKGFuZ2xlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJydXNoZWQgPSBzZWxlY3RlZChhcmNzKTtcbiAgICAgICAgYXJjcy5hY3RpdmUgPSB1bmRlZmluZWQ7XG4gICAgICAgIF9fLmJydXNoZWQgPSBicnVzaGVkO1xuICAgICAgICBwYy5yZW5kZXJCcnVzaGVkKCk7XG4gICAgICAgIGV2ZW50cy5icnVzaGVuZC5jYWxsKHBjLCBfXy5icnVzaGVkKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYnJ1c2hSZXNldChhcmNzKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaWRzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYXJjcykuZmlsdGVyKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgcmV0dXJuICFpc05hTihkKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlkcy5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgYXJjcy5hY3RpdmUgPSBkO1xuICAgICAgICAgIHJlbW92ZVN0cnVtKGFyY3MpO1xuICAgICAgICB9KTtcbiAgICAgICAgb25EcmFnRW5kKGFyY3MpKCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGwoKSB7XG4gICAgICB2YXIgZHJhZyA9IGQzLmJlaGF2aW9yLmRyYWcoKTsgLy8gTWFwIG9mIGN1cnJlbnQgYXJjcy4gYXJjcyBhcmUgc3RvcmVkIHBlciBzZWdtZW50IG9mIHRoZSBQQy4gQSBzZWdtZW50LFxuICAgICAgLy8gYmVpbmcgdGhlIGFyZWEgYmV0d2VlbiB0d28gYXhlcy4gVGhlIGxlZnQgbW9zdCBhcmVhIGlzIGluZGV4ZWQgYXQgMC5cblxuICAgICAgYXJjcy5hY3RpdmUgPSB1bmRlZmluZWQ7IC8vIFJldHVybnMgdGhlIHdpZHRoIG9mIHRoZSBQQyBzZWdtZW50IHdoZXJlIGN1cnJlbnRseSBhIGFyYyBpcyBiZWluZ1xuICAgICAgLy8gcGxhY2VkLiBOT1RFOiBldmVuIHRob3VnaCB0aGV5IGFyZSBldmVubHkgc3BhY2VkIGluIG91ciBjdXJyZW50XG4gICAgICAvLyBpbXBsZW1lbnRhdGlvbiwgd2Uga2VlcCBmb3Igd2hlbiBub24tZXZlbiBzcGFjZWQgc2VnbWVudHMgYXJlIHN1cHBvcnRlZCBhc1xuICAgICAgLy8gd2VsbC5cblxuICAgICAgYXJjcy53aWR0aCA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICB2YXIgYXJjID0gYXJjc1tpZF07XG5cbiAgICAgICAgaWYgKGFyYyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhcmMubWF4WCAtIGFyYy5taW5YO1xuICAgICAgfTsgLy8gcmV0dXJucyBhbmdsZXMgaW4gWy1QSS8yLCBQSS8yXVxuXG5cbiAgICAgIGFuZ2xlID0gZnVuY3Rpb24gYW5nbGUocDEsIHAyKSB7XG4gICAgICAgIHZhciBhID0gcDFbMF0gLSBwMlswXSxcbiAgICAgICAgICAgIGIgPSBwMVsxXSAtIHAyWzFdLFxuICAgICAgICAgICAgYyA9IGh5cG90aGVudXNlKGEsIGIpO1xuICAgICAgICByZXR1cm4gTWF0aC5hc2luKGIgLyBjKTtcbiAgICAgIH07IC8vIHJldHVybnMgYW5nbGVzIGluIFswLCAyICogUEldXG5cblxuICAgICAgYXJjcy5lbmRBbmdsZSA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICB2YXIgYXJjID0gYXJjc1tpZF07XG5cbiAgICAgICAgaWYgKGFyYyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzQW5nbGUgPSBhbmdsZShhcmMucDEsIGFyYy5wMiksXG4gICAgICAgICAgICB1QW5nbGUgPSAtc0FuZ2xlICsgTWF0aC5QSSAvIDI7XG5cbiAgICAgICAgaWYgKGFyYy5wMVswXSA+IGFyYy5wMlswXSkge1xuICAgICAgICAgIHVBbmdsZSA9IDIgKiBNYXRoLlBJIC0gdUFuZ2xlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHVBbmdsZTtcbiAgICAgIH07XG5cbiAgICAgIGFyY3Muc3RhcnRBbmdsZSA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICB2YXIgYXJjID0gYXJjc1tpZF07XG5cbiAgICAgICAgaWYgKGFyYyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzQW5nbGUgPSBhbmdsZShhcmMucDEsIGFyYy5wMyksXG4gICAgICAgICAgICB1QW5nbGUgPSAtc0FuZ2xlICsgTWF0aC5QSSAvIDI7XG5cbiAgICAgICAgaWYgKGFyYy5wMVswXSA+IGFyYy5wM1swXSkge1xuICAgICAgICAgIHVBbmdsZSA9IDIgKiBNYXRoLlBJIC0gdUFuZ2xlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHVBbmdsZTtcbiAgICAgIH07XG5cbiAgICAgIGFyY3MubGVuZ3RoID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHZhciBhcmMgPSBhcmNzW2lkXTtcblxuICAgICAgICBpZiAoYXJjID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGEgPSBhcmMucDFbMF0gLSBhcmMucDJbMF0sXG4gICAgICAgICAgICBiID0gYXJjLnAxWzFdIC0gYXJjLnAyWzFdLFxuICAgICAgICAgICAgYyA9IGh5cG90aGVudXNlKGEsIGIpO1xuICAgICAgICByZXR1cm4gYztcbiAgICAgIH07XG5cbiAgICAgIHBjLm9uKCdheGVzcmVvcmRlci5hcmNzJywgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaWRzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYXJjcykuZmlsdGVyKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgcmV0dXJuICFpc05hTihkKTtcbiAgICAgICAgfSk7IC8vIENoZWNrcyBpZiB0aGUgZmlyc3QgZGltZW5zaW9uIGlzIGRpcmVjdGx5IGxlZnQgb2YgdGhlIHNlY29uZCBkaW1lbnNpb24uXG5cbiAgICAgICAgZnVuY3Rpb24gY29uc2VjdXRpdmUoZmlyc3QsIHNlY29uZCkge1xuICAgICAgICAgIHZhciBsZW5ndGggPSBfXy5kaW1lbnNpb25zLmxlbmd0aDtcbiAgICAgICAgICByZXR1cm4gX18uZGltZW5zaW9ucy5zb21lKGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICAgICAgICByZXR1cm4gZCA9PT0gZmlyc3QgPyBpICsgaSA8IGxlbmd0aCAmJiBfXy5kaW1lbnNpb25zW2kgKyAxXSA9PT0gc2Vjb25kIDogZmFsc2U7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaWRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAvLyBXZSBoYXZlIHNvbWUgYXJjcywgd2hpY2ggbWlnaHQgbmVlZCB0byBiZSByZW1vdmVkLlxuICAgICAgICAgIGlkcy5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICB2YXIgZGltcyA9IGFyY3NbZF0uZGltcztcbiAgICAgICAgICAgIGFyY3MuYWN0aXZlID0gZDsgLy8gSWYgdGhlIHR3byBkaW1lbnNpb25zIG9mIHRoZSBjdXJyZW50IGFyYyBhcmUgbm90IG5leHQgdG8gZWFjaCBvdGhlclxuICAgICAgICAgICAgLy8gYW55IG1vcmUsIHRoYW4gd2UnbGwgbmVlZCB0byByZW1vdmUgdGhlIGFyYy4gT3RoZXJ3aXNlIHdlIGtlZXAgaXQuXG5cbiAgICAgICAgICAgIGlmICghY29uc2VjdXRpdmUoZGltcy5sZWZ0LCBkaW1zLnJpZ2h0KSkge1xuICAgICAgICAgICAgICByZW1vdmVTdHJ1bShhcmNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBvbkRyYWdFbmQoYXJjcykoKTtcbiAgICAgICAgfVxuICAgICAgfSk7IC8vIEFkZCBhIG5ldyBzdmcgZ3JvdXAgaW4gd2hpY2ggd2UgZHJhdyB0aGUgYXJjcy5cblxuICAgICAgcGMuc2VsZWN0aW9uLnNlbGVjdCgnc3ZnJykuYXBwZW5kKCdnJykuYXR0cignaWQnLCAnYXJjcycpLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIF9fLm1hcmdpbi5sZWZ0ICsgJywnICsgX18ubWFyZ2luLnRvcCArICcpJyk7IC8vIEluc3RhbGwgdGhlIHJlcXVpcmVkIGJydXNoUmVzZXQgZnVuY3Rpb25cblxuICAgICAgcGMuYnJ1c2hSZXNldCA9IGJydXNoUmVzZXQoYXJjcyk7XG4gICAgICBkcmFnLm9uKCdkcmFnc3RhcnQnLCBvbkRyYWdTdGFydChhcmNzKSkub24oJ2RyYWcnLCBvbkRyYWcoYXJjcykpLm9uKCdkcmFnZW5kJywgb25EcmFnRW5kKGFyY3MpKTsgLy8gTk9URTogVGhlIHN0eWxpbmcgbmVlZHMgdG8gYmUgZG9uZSBoZXJlIGFuZCBub3QgaW4gdGhlIGNzcy4gVGhpcyBpcyBiZWNhdXNlXG4gICAgICAvLyAgICAgICBmb3IgMUQgYnJ1c2hpbmcsIHRoZSBjYW52YXMgbGF5ZXJzIHNob3VsZCBub3QgbGlzdGVuIHRvXG4gICAgICAvLyAgICAgICBwb2ludGVyLWV2ZW50cy5cblxuICAgICAgc3RydW1SZWN0ID0gcGMuc2VsZWN0aW9uLnNlbGVjdCgnc3ZnJykuaW5zZXJ0KCdyZWN0JywgJ2cjYXJjcycpLmF0dHIoJ2lkJywgJ2FyYy1ldmVudHMnKS5hdHRyKCd4JywgX18ubWFyZ2luLmxlZnQpLmF0dHIoJ3knLCBfXy5tYXJnaW4udG9wKS5hdHRyKCd3aWR0aCcsIHcoKSkuYXR0cignaGVpZ2h0JywgaCgpICsgMikuc3R5bGUoJ29wYWNpdHknLCAwKS5jYWxsKGRyYWcpO1xuICAgIH1cblxuICAgIGJydXNoLm1vZGVzWydhbmd1bGFyJ10gPSB7XG4gICAgICBpbnN0YWxsOiBpbnN0YWxsLFxuICAgICAgdW5pbnN0YWxsOiBmdW5jdGlvbiB1bmluc3RhbGwoKSB7XG4gICAgICAgIHBjLnNlbGVjdGlvbi5zZWxlY3QoJ3N2ZycpLnNlbGVjdCgnZyNhcmNzJykucmVtb3ZlKCk7XG4gICAgICAgIHBjLnNlbGVjdGlvbi5zZWxlY3QoJ3N2ZycpLnNlbGVjdCgncmVjdCNhcmMtZXZlbnRzJykucmVtb3ZlKCk7XG4gICAgICAgIHBjLm9uKCdheGVzcmVvcmRlci5hcmNzJywgdW5kZWZpbmVkKTtcbiAgICAgICAgZGVsZXRlIHBjLmJydXNoUmVzZXQ7XG4gICAgICAgIHN0cnVtUmVjdCA9IHVuZGVmaW5lZDtcbiAgICAgIH0sXG4gICAgICBzZWxlY3RlZDogc2VsZWN0ZWQsXG4gICAgICBicnVzaFN0YXRlOiBmdW5jdGlvbiBicnVzaFN0YXRlKCkge1xuICAgICAgICByZXR1cm4gYXJjcztcbiAgICAgIH1cbiAgICB9O1xuICB9KSgpO1xuXG4gIHBjLmludGVyYWN0aXZlID0gZnVuY3Rpb24gKCkge1xuICAgIGZsYWdzLmludGVyYWN0aXZlID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTsgLy8gZXhwb3NlIGEgZmV3IG9iamVjdHNcblxuXG4gIHBjLnhzY2FsZSA9IHhzY2FsZTtcbiAgcGMueXNjYWxlID0geXNjYWxlO1xuICBwYy5jdHggPSBjdHg7XG4gIHBjLmNhbnZhcyA9IGNhbnZhcztcblxuICBwYy5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBnO1xuICB9OyAvLyByZXNjYWxlIGZvciBoZWlnaHQsIHdpZHRoIGFuZCBtYXJnaW5zXG4gIC8vIFRPRE8gY3VycmVudGx5IGFzc3VtZXMgY2hhcnQgaXMgYnJ1c2hhYmxlLCBhbmQgZGVzdHJveXMgb2xkIGJydXNoZXNcblxuXG4gIHBjLnJlc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBzZWxlY3Rpb24gc2l6ZVxuICAgIHBjLnNlbGVjdGlvbi5zZWxlY3QoJ3N2ZycpLmF0dHIoJ3dpZHRoJywgX18ud2lkdGgpLmF0dHIoJ2hlaWdodCcsIF9fLmhlaWdodCk7XG4gICAgcGMuc3ZnLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIF9fLm1hcmdpbi5sZWZ0ICsgJywnICsgX18ubWFyZ2luLnRvcCArICcpJyk7IC8vIEZJWE1FOiB0aGUgY3VycmVudCBicnVzaCBzdGF0ZSBzaG91bGQgcGFzcyB0aHJvdWdoXG5cbiAgICBpZiAoZmxhZ3MuYnJ1c2hhYmxlKSBwYy5icnVzaFJlc2V0KCk7IC8vIHNjYWxlc1xuXG4gICAgcGMuYXV0b3NjYWxlKCk7IC8vIGF4ZXMsIGRlc3Ryb3lzIG9sZCBicnVzaGVzLlxuXG4gICAgaWYgKGcpIHBjLmNyZWF0ZUF4ZXMoKTtcbiAgICBpZiAoZmxhZ3MuYnJ1c2hhYmxlKSBwYy5icnVzaGFibGUoKTtcbiAgICBpZiAoZmxhZ3MucmVvcmRlcmFibGUpIHBjLnJlb3JkZXJhYmxlKCk7XG4gICAgZXZlbnRzLnJlc2l6ZS5jYWxsKHRoaXMsIHtcbiAgICAgIHdpZHRoOiBfXy53aWR0aCxcbiAgICAgIGhlaWdodDogX18uaGVpZ2h0LFxuICAgICAgbWFyZ2luOiBfXy5tYXJnaW5cbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTsgLy8gaGlnaGxpZ2h0IGFuIGFycmF5IG9mIGRhdGFcblxuXG4gIHBjLmhpZ2hsaWdodCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBfXy5oaWdobGlnaHRlZDtcbiAgICB9XG5cbiAgICBfXy5oaWdobGlnaHRlZCA9IGRhdGE7XG4gICAgcGMuY2xlYXIoJ2hpZ2hsaWdodCcpO1xuICAgIGQzLnNlbGVjdEFsbChbY2FudmFzLmZvcmVncm91bmQsIGNhbnZhcy5icnVzaGVkXSkuY2xhc3NlZCgnZmFkZWQnLCB0cnVlKTtcbiAgICBkYXRhLmZvckVhY2gocGF0aF9oaWdobGlnaHQpO1xuICAgIGV2ZW50cy5oaWdobGlnaHQuY2FsbCh0aGlzLCBkYXRhKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTsgLy8gY2xlYXIgaGlnaGxpZ2h0aW5nXG5cblxuICBwYy51bmhpZ2hsaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgICBfXy5oaWdobGlnaHRlZCA9IFtdO1xuICAgIHBjLmNsZWFyKCdoaWdobGlnaHQnKTtcbiAgICBkMy5zZWxlY3RBbGwoW2NhbnZhcy5mb3JlZ3JvdW5kLCBjYW52YXMuYnJ1c2hlZF0pLmNsYXNzZWQoJ2ZhZGVkJywgZmFsc2UpO1xuICAgIHJldHVybiB0aGlzO1xuICB9OyAvLyBjYWxjdWxhdGUgMmQgaW50ZXJzZWN0aW9uIG9mIGxpbmUgYS0+YiB3aXRoIGxpbmUgYy0+ZFxuICAvLyBwb2ludHMgYXJlIG9iamVjdHMgd2l0aCB4IGFuZCB5IHByb3BlcnRpZXNcblxuXG4gIHBjLmludGVyc2VjdGlvbiA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6ICgoYS54ICogYi55IC0gYS55ICogYi54KSAqIChjLnggLSBkLngpIC0gKGEueCAtIGIueCkgKiAoYy54ICogZC55IC0gYy55ICogZC54KSkgLyAoKGEueCAtIGIueCkgKiAoYy55IC0gZC55KSAtIChhLnkgLSBiLnkpICogKGMueCAtIGQueCkpLFxuICAgICAgeTogKChhLnggKiBiLnkgLSBhLnkgKiBiLngpICogKGMueSAtIGQueSkgLSAoYS55IC0gYi55KSAqIChjLnggKiBkLnkgLSBjLnkgKiBkLngpKSAvICgoYS54IC0gYi54KSAqIChjLnkgLSBkLnkpIC0gKGEueSAtIGIueSkgKiAoYy54IC0gZC54KSlcbiAgICB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIHBvc2l0aW9uKGQpIHtcbiAgICB2YXIgdiA9IGRyYWdnaW5nW2RdO1xuICAgIHJldHVybiB2ID09IG51bGwgPyB4c2NhbGUoZCkgOiB2O1xuICB9XG5cbiAgcGMudmVyc2lvbiA9ICcwLjcuMCc7IC8vIHRoaXMgZGVzY3JpcHRpdmUgdGV4dCBzaG91bGQgbGl2ZSB3aXRoIG90aGVyIGludHJvc3BlY3RpdmUgbWV0aG9kc1xuXG4gIHBjLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAnUGFyYWxsZWwgQ29vcmRpbmF0ZXM6ICcgKyBfXy5kaW1lbnNpb25zLmxlbmd0aCArICcgZGltZW5zaW9ucyAoJyArIGQzLmtleXMoX18uZGF0YVswXSkubGVuZ3RoICsgJyB0b3RhbCkgLCAnICsgX18uZGF0YS5sZW5ndGggKyAnIHJvd3MnO1xuICB9O1xuXG4gIHJldHVybiBwYztcbn1cblxuZDMucmVuZGVyUXVldWUgPSBmdW5jdGlvbiAoZnVuYykge1xuICB2YXIgX3F1ZXVlID0gW10sXG4gICAgICAvLyBkYXRhIHRvIGJlIHJlbmRlcmVkXG4gIF9yYXRlID0gMTAsXG4gICAgICAvLyBudW1iZXIgb2YgY2FsbHMgcGVyIGZyYW1lXG4gIF9jbGVhciA9IGZ1bmN0aW9uIF9jbGVhcigpIHt9LFxuICAgICAgLy8gY2xlYXJpbmcgZnVuY3Rpb25cbiAgX2kgPSAwOyAvLyBjdXJyZW50IGl0ZXJhdGlvblxuXG5cbiAgdmFyIHJxID0gZnVuY3Rpb24gcnEoZGF0YSkge1xuICAgIGlmIChkYXRhKSBycS5kYXRhKGRhdGEpO1xuICAgIHJxLmludmFsaWRhdGUoKTtcblxuICAgIF9jbGVhcigpO1xuXG4gICAgcnEucmVuZGVyKCk7XG4gIH07XG5cbiAgcnEucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIF9pID0gMDtcbiAgICB2YXIgdmFsaWQgPSB0cnVlO1xuXG4gICAgcnEuaW52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhbGlkID0gZmFsc2U7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGRvRnJhbWUoKSB7XG4gICAgICBpZiAoIXZhbGlkKSByZXR1cm4gdHJ1ZTtcbiAgICAgIGlmIChfaSA+IF9xdWV1ZS5sZW5ndGgpIHJldHVybiB0cnVlOyAvLyBUeXBpY2FsIGQzIGJlaGF2aW9yIGlzIHRvIHBhc3MgYSBkYXRhIGl0ZW0gKmFuZCogaXRzIGluZGV4LiBBcyB0aGVcbiAgICAgIC8vIHJlbmRlciBxdWV1ZSBzcGxpdHMgdGhlIG9yaWdpbmFsIGRhdGEgc2V0LCB3ZSdsbCBoYXZlIHRvIGJlIHNsaWdodGx5XG4gICAgICAvLyBtb3JlIGNhcmVmdWxsIGFib3V0IHBhc3NpbmcgdGhlIGNvcnJlY3QgaW5kZXggd2l0aCB0aGUgZGF0YSBpdGVtLlxuXG4gICAgICB2YXIgZW5kID0gTWF0aC5taW4oX2kgKyBfcmF0ZSwgX3F1ZXVlLmxlbmd0aCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSBfaTsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICAgIGZ1bmMoX3F1ZXVlW2ldLCBpKTtcbiAgICAgIH1cblxuICAgICAgX2kgKz0gX3JhdGU7XG4gICAgfVxuXG4gICAgZDMudGltZXIoZG9GcmFtZSk7XG4gIH07XG5cbiAgcnEuZGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgcnEuaW52YWxpZGF0ZSgpO1xuICAgIF9xdWV1ZSA9IGRhdGEuc2xpY2UoMCk7XG4gICAgcmV0dXJuIHJxO1xuICB9O1xuXG4gIHJxLnJhdGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBfcmF0ZTtcbiAgICBfcmF0ZSA9IHZhbHVlO1xuICAgIHJldHVybiBycTtcbiAgfTtcblxuICBycS5yZW1haW5pbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9xdWV1ZS5sZW5ndGggLSBfaTtcbiAgfTsgLy8gY2xlYXIgdGhlIGNhbnZhc1xuXG5cbiAgcnEuY2xlYXIgPSBmdW5jdGlvbiAoZnVuYykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgX2NsZWFyKCk7XG5cbiAgICAgIHJldHVybiBycTtcbiAgICB9XG5cbiAgICBfY2xlYXIgPSBmdW5jO1xuICAgIHJldHVybiBycTtcbiAgfTtcblxuICBycS5pbnZhbGlkYXRlID0gZnVuY3Rpb24gKCkge307XG5cbiAgcmV0dXJuIHJxO1xufTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@superset-ui/legacy-plugin-chart-parallel-coordinates/esm/vendor/parcoords/d3.parcoords.js\n");

/***/ }),

/***/ "./node_modules/@superset-ui/legacy-plugin-chart-parallel-coordinates/esm/vendor/parcoords/divgrid.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/@superset-ui/legacy-plugin-chart-parallel-coordinates/esm/vendor/parcoords/divgrid.js ***!
  \************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* [LICENSE TBD] */\n\n/* eslint-disable */\n// from http://bl.ocks.org/3687826\n/* harmony default export */ __webpack_exports__[\"default\"] = (function (config) {\n  var columns = [];\n\n  var dg = function dg(selection) {\n    if (columns.length == 0) columns = d3.keys(selection.data()[0][0]); // header\n\n    selection.selectAll('.header').data([true]).enter().append('div').attr('class', 'header');\n    var header = selection.select('.header').selectAll('.cell').data(columns);\n    header.enter().append('div').attr('class', function (d, i) {\n      return 'col-' + i;\n    }).classed('cell', true);\n    selection.selectAll('.header .cell').text(function (d) {\n      return d;\n    });\n    header.exit().remove(); // rows\n\n    var rows = selection.selectAll('.row').data(function (d) {\n      return d;\n    });\n    rows.enter().append('div').attr('class', 'row');\n    rows.exit().remove();\n    var cells = selection.selectAll('.row').selectAll('.cell').data(function (d) {\n      return columns.map(function (col) {\n        return d[col];\n      });\n    }); // cells\n\n    cells.enter().append('div').attr('class', function (d, i) {\n      return 'col-' + i;\n    }).classed('cell', true);\n    cells.exit().remove();\n    selection.selectAll('.cell').text(function (d) {\n      return d;\n    });\n    return dg;\n  };\n\n  dg.columns = function (_) {\n    if (!arguments.length) return columns;\n    columns = _;\n    return this;\n  };\n\n  return dg;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHN1cGVyc2V0LXVpL2xlZ2FjeS1wbHVnaW4tY2hhcnQtcGFyYWxsZWwtY29vcmRpbmF0ZXMvZXNtL3ZlbmRvci9wYXJjb29yZHMvZGl2Z3JpZC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ac3VwZXJzZXQtdWkvbGVnYWN5LXBsdWdpbi1jaGFydC1wYXJhbGxlbC1jb29yZGluYXRlcy9lc20vdmVuZG9yL3BhcmNvb3Jkcy9kaXZncmlkLmpzPzA5YTEiXSwic291cmNlc0NvbnRlbnQiOlsiLyogW0xJQ0VOU0UgVEJEXSAqL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuLy8gZnJvbSBodHRwOi8vYmwub2Nrcy5vcmcvMzY4NzgyNlxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKGNvbmZpZykge1xuICB2YXIgY29sdW1ucyA9IFtdO1xuXG4gIHZhciBkZyA9IGZ1bmN0aW9uIGRnKHNlbGVjdGlvbikge1xuICAgIGlmIChjb2x1bW5zLmxlbmd0aCA9PSAwKSBjb2x1bW5zID0gZDMua2V5cyhzZWxlY3Rpb24uZGF0YSgpWzBdWzBdKTsgLy8gaGVhZGVyXG5cbiAgICBzZWxlY3Rpb24uc2VsZWN0QWxsKCcuaGVhZGVyJykuZGF0YShbdHJ1ZV0pLmVudGVyKCkuYXBwZW5kKCdkaXYnKS5hdHRyKCdjbGFzcycsICdoZWFkZXInKTtcbiAgICB2YXIgaGVhZGVyID0gc2VsZWN0aW9uLnNlbGVjdCgnLmhlYWRlcicpLnNlbGVjdEFsbCgnLmNlbGwnKS5kYXRhKGNvbHVtbnMpO1xuICAgIGhlYWRlci5lbnRlcigpLmFwcGVuZCgnZGl2JykuYXR0cignY2xhc3MnLCBmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgcmV0dXJuICdjb2wtJyArIGk7XG4gICAgfSkuY2xhc3NlZCgnY2VsbCcsIHRydWUpO1xuICAgIHNlbGVjdGlvbi5zZWxlY3RBbGwoJy5oZWFkZXIgLmNlbGwnKS50ZXh0KGZ1bmN0aW9uIChkKSB7XG4gICAgICByZXR1cm4gZDtcbiAgICB9KTtcbiAgICBoZWFkZXIuZXhpdCgpLnJlbW92ZSgpOyAvLyByb3dzXG5cbiAgICB2YXIgcm93cyA9IHNlbGVjdGlvbi5zZWxlY3RBbGwoJy5yb3cnKS5kYXRhKGZ1bmN0aW9uIChkKSB7XG4gICAgICByZXR1cm4gZDtcbiAgICB9KTtcbiAgICByb3dzLmVudGVyKCkuYXBwZW5kKCdkaXYnKS5hdHRyKCdjbGFzcycsICdyb3cnKTtcbiAgICByb3dzLmV4aXQoKS5yZW1vdmUoKTtcbiAgICB2YXIgY2VsbHMgPSBzZWxlY3Rpb24uc2VsZWN0QWxsKCcucm93Jykuc2VsZWN0QWxsKCcuY2VsbCcpLmRhdGEoZnVuY3Rpb24gKGQpIHtcbiAgICAgIHJldHVybiBjb2x1bW5zLm1hcChmdW5jdGlvbiAoY29sKSB7XG4gICAgICAgIHJldHVybiBkW2NvbF07XG4gICAgICB9KTtcbiAgICB9KTsgLy8gY2VsbHNcblxuICAgIGNlbGxzLmVudGVyKCkuYXBwZW5kKCdkaXYnKS5hdHRyKCdjbGFzcycsIGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICByZXR1cm4gJ2NvbC0nICsgaTtcbiAgICB9KS5jbGFzc2VkKCdjZWxsJywgdHJ1ZSk7XG4gICAgY2VsbHMuZXhpdCgpLnJlbW92ZSgpO1xuICAgIHNlbGVjdGlvbi5zZWxlY3RBbGwoJy5jZWxsJykudGV4dChmdW5jdGlvbiAoZCkge1xuICAgICAgcmV0dXJuIGQ7XG4gICAgfSk7XG4gICAgcmV0dXJuIGRnO1xuICB9O1xuXG4gIGRnLmNvbHVtbnMgPSBmdW5jdGlvbiAoXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGNvbHVtbnM7XG4gICAgY29sdW1ucyA9IF87XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgcmV0dXJuIGRnO1xufSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@superset-ui/legacy-plugin-chart-parallel-coordinates/esm/vendor/parcoords/divgrid.js\n");

/***/ }),

/***/ "./node_modules/css-loader/index.js?!./node_modules/@superset-ui/legacy-plugin-chart-parallel-coordinates/esm/vendor/parcoords/d3.parcoords.css":
/*!******************************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader??ref--7-1!./node_modules/@superset-ui/legacy-plugin-chart-parallel-coordinates/esm/vendor/parcoords/d3.parcoords.css ***!
  \******************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(/*! ../../../../../css-loader/lib/css-base.js */ \"./node_modules/css-loader/lib/css-base.js\")(true);\n// imports\n\n\n// module\nexports.push([module.i, \"/* [LICENSE TBD] */\\n.parcoords svg,\\n.parcoords canvas {\\n  font-size: 12px;\\n  position: absolute;\\n}\\n.parcoords > canvas {\\n  pointer-events: none;\\n}\\n\\n.parcoords text.label {\\n  font: 100%;\\n  font-size: 12px;\\n  cursor: drag;\\n}\\n\\n.parcoords rect.background {\\n  fill: transparent;\\n}\\n.parcoords rect.background:hover {\\n  fill: rgba(120, 120, 120, 0.2);\\n}\\n.parcoords .resize rect {\\n  fill: rgba(0, 0, 0, 0.1);\\n}\\n.parcoords rect.extent {\\n  fill: rgba(255, 255, 255, 0.25);\\n  stroke: rgba(0, 0, 0, 0.6);\\n}\\n.parcoords .axis line,\\n.parcoords .axis path {\\n  fill: none;\\n  stroke: #222;\\n  shape-rendering: crispEdges;\\n}\\n.parcoords canvas {\\n  opacity: 1;\\n  -moz-transition: opacity 0.3s;\\n  -webkit-transition: opacity 0.3s;\\n  -o-transition: opacity 0.3s;\\n}\\n.parcoords canvas.faded {\\n  opacity: 0.25;\\n}\\n.parcoords {\\n  -webkit-touch-callout: none;\\n  -webkit-user-select: none;\\n  -khtml-user-select: none;\\n  -moz-user-select: none;\\n  -ms-user-select: none;\\n  user-select: none;\\n  background-color: white;\\n}\\n\\n/* data table styles */\\n.parcoords .row,\\n.parcoords .header {\\n  clear: left;\\n  font-size: 12px;\\n  line-height: 18px;\\n  height: 18px;\\n  margin: 0px;\\n}\\n.parcoords .row:nth-child(odd) {\\n  background: rgba(0, 0, 0, 0.05);\\n}\\n.parcoords .header {\\n  font-weight: bold;\\n}\\n.parcoords .cell {\\n  float: left;\\n  overflow: hidden;\\n  white-space: nowrap;\\n  width: 100px;\\n  height: 18px;\\n}\\n.parcoords .col-0 {\\n  width: 180px;\\n}\\n\", \"\", {\"version\":3,\"sources\":[\"/app/superset-frontend/node_modules/@superset-ui/legacy-plugin-chart-parallel-coordinates/esm/vendor/parcoords/d3.parcoords.css\"],\"names\":[],\"mappings\":\"AAAA,mBAAmB;AACnB;;EAEE,gBAAgB;EAChB,mBAAmB;CACpB;AACD;EACE,qBAAqB;CACtB;;AAED;EACE,WAAW;EACX,gBAAgB;EAChB,aAAa;CACd;;AAED;EACE,kBAAkB;CACnB;AACD;EACE,+BAA+B;CAChC;AACD;EACE,yBAAyB;CAC1B;AACD;EACE,gCAAgC;EAChC,2BAA2B;CAC5B;AACD;;EAEE,WAAW;EACX,aAAa;EACb,4BAA4B;CAC7B;AACD;EACE,WAAW;EACX,8BAA8B;EAC9B,iCAAiC;EACjC,4BAA4B;CAC7B;AACD;EACE,cAAc;CACf;AACD;EACE,4BAA4B;EAC5B,0BAA0B;EAC1B,yBAAyB;EACzB,uBAAuB;EACvB,sBAAsB;EACtB,kBAAkB;EAClB,wBAAwB;CACzB;;AAED,uBAAuB;AACvB;;EAEE,YAAY;EACZ,gBAAgB;EAChB,kBAAkB;EAClB,aAAa;EACb,YAAY;CACb;AACD;EACE,gCAAgC;CACjC;AACD;EACE,kBAAkB;CACnB;AACD;EACE,YAAY;EACZ,iBAAiB;EACjB,oBAAoB;EACpB,aAAa;EACb,aAAa;CACd;AACD;EACE,aAAa;CACd\",\"file\":\"d3.parcoords.css\",\"sourcesContent\":[\"/* [LICENSE TBD] */\\n.parcoords svg,\\n.parcoords canvas {\\n  font-size: 12px;\\n  position: absolute;\\n}\\n.parcoords > canvas {\\n  pointer-events: none;\\n}\\n\\n.parcoords text.label {\\n  font: 100%;\\n  font-size: 12px;\\n  cursor: drag;\\n}\\n\\n.parcoords rect.background {\\n  fill: transparent;\\n}\\n.parcoords rect.background:hover {\\n  fill: rgba(120, 120, 120, 0.2);\\n}\\n.parcoords .resize rect {\\n  fill: rgba(0, 0, 0, 0.1);\\n}\\n.parcoords rect.extent {\\n  fill: rgba(255, 255, 255, 0.25);\\n  stroke: rgba(0, 0, 0, 0.6);\\n}\\n.parcoords .axis line,\\n.parcoords .axis path {\\n  fill: none;\\n  stroke: #222;\\n  shape-rendering: crispEdges;\\n}\\n.parcoords canvas {\\n  opacity: 1;\\n  -moz-transition: opacity 0.3s;\\n  -webkit-transition: opacity 0.3s;\\n  -o-transition: opacity 0.3s;\\n}\\n.parcoords canvas.faded {\\n  opacity: 0.25;\\n}\\n.parcoords {\\n  -webkit-touch-callout: none;\\n  -webkit-user-select: none;\\n  -khtml-user-select: none;\\n  -moz-user-select: none;\\n  -ms-user-select: none;\\n  user-select: none;\\n  background-color: white;\\n}\\n\\n/* data table styles */\\n.parcoords .row,\\n.parcoords .header {\\n  clear: left;\\n  font-size: 12px;\\n  line-height: 18px;\\n  height: 18px;\\n  margin: 0px;\\n}\\n.parcoords .row:nth-child(odd) {\\n  background: rgba(0, 0, 0, 0.05);\\n}\\n.parcoords .header {\\n  font-weight: bold;\\n}\\n.parcoords .cell {\\n  float: left;\\n  overflow: hidden;\\n  white-space: nowrap;\\n  width: 100px;\\n  height: 18px;\\n}\\n.parcoords .col-0 {\\n  width: 180px;\\n}\\n\"],\"sourceRoot\":\"\"}]);\n\n// exports\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz8hLi9ub2RlX21vZHVsZXMvQHN1cGVyc2V0LXVpL2xlZ2FjeS1wbHVnaW4tY2hhcnQtcGFyYWxsZWwtY29vcmRpbmF0ZXMvZXNtL3ZlbmRvci9wYXJjb29yZHMvZDMucGFyY29vcmRzLmNzcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ac3VwZXJzZXQtdWkvbGVnYWN5LXBsdWdpbi1jaGFydC1wYXJhbGxlbC1jb29yZGluYXRlcy9lc20vdmVuZG9yL3BhcmNvb3Jkcy9kMy5wYXJjb29yZHMuY3NzP2IyZTYiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uLy4uL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKHRydWUpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLyogW0xJQ0VOU0UgVEJEXSAqL1xcbi5wYXJjb29yZHMgc3ZnLFxcbi5wYXJjb29yZHMgY2FudmFzIHtcXG4gIGZvbnQtc2l6ZTogMTJweDtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG59XFxuLnBhcmNvb3JkcyA+IGNhbnZhcyB7XFxuICBwb2ludGVyLWV2ZW50czogbm9uZTtcXG59XFxuXFxuLnBhcmNvb3JkcyB0ZXh0LmxhYmVsIHtcXG4gIGZvbnQ6IDEwMCU7XFxuICBmb250LXNpemU6IDEycHg7XFxuICBjdXJzb3I6IGRyYWc7XFxufVxcblxcbi5wYXJjb29yZHMgcmVjdC5iYWNrZ3JvdW5kIHtcXG4gIGZpbGw6IHRyYW5zcGFyZW50O1xcbn1cXG4ucGFyY29vcmRzIHJlY3QuYmFja2dyb3VuZDpob3ZlciB7XFxuICBmaWxsOiByZ2JhKDEyMCwgMTIwLCAxMjAsIDAuMik7XFxufVxcbi5wYXJjb29yZHMgLnJlc2l6ZSByZWN0IHtcXG4gIGZpbGw6IHJnYmEoMCwgMCwgMCwgMC4xKTtcXG59XFxuLnBhcmNvb3JkcyByZWN0LmV4dGVudCB7XFxuICBmaWxsOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMjUpO1xcbiAgc3Ryb2tlOiByZ2JhKDAsIDAsIDAsIDAuNik7XFxufVxcbi5wYXJjb29yZHMgLmF4aXMgbGluZSxcXG4ucGFyY29vcmRzIC5heGlzIHBhdGgge1xcbiAgZmlsbDogbm9uZTtcXG4gIHN0cm9rZTogIzIyMjtcXG4gIHNoYXBlLXJlbmRlcmluZzogY3Jpc3BFZGdlcztcXG59XFxuLnBhcmNvb3JkcyBjYW52YXMge1xcbiAgb3BhY2l0eTogMTtcXG4gIC1tb3otdHJhbnNpdGlvbjogb3BhY2l0eSAwLjNzO1xcbiAgLXdlYmtpdC10cmFuc2l0aW9uOiBvcGFjaXR5IDAuM3M7XFxuICAtby10cmFuc2l0aW9uOiBvcGFjaXR5IDAuM3M7XFxufVxcbi5wYXJjb29yZHMgY2FudmFzLmZhZGVkIHtcXG4gIG9wYWNpdHk6IDAuMjU7XFxufVxcbi5wYXJjb29yZHMge1xcbiAgLXdlYmtpdC10b3VjaC1jYWxsb3V0OiBub25lO1xcbiAgLXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZTtcXG4gIC1raHRtbC11c2VyLXNlbGVjdDogbm9uZTtcXG4gIC1tb3otdXNlci1zZWxlY3Q6IG5vbmU7XFxuICAtbXMtdXNlci1zZWxlY3Q6IG5vbmU7XFxuICB1c2VyLXNlbGVjdDogbm9uZTtcXG4gIGJhY2tncm91bmQtY29sb3I6IHdoaXRlO1xcbn1cXG5cXG4vKiBkYXRhIHRhYmxlIHN0eWxlcyAqL1xcbi5wYXJjb29yZHMgLnJvdyxcXG4ucGFyY29vcmRzIC5oZWFkZXIge1xcbiAgY2xlYXI6IGxlZnQ7XFxuICBmb250LXNpemU6IDEycHg7XFxuICBsaW5lLWhlaWdodDogMThweDtcXG4gIGhlaWdodDogMThweDtcXG4gIG1hcmdpbjogMHB4O1xcbn1cXG4ucGFyY29vcmRzIC5yb3c6bnRoLWNoaWxkKG9kZCkge1xcbiAgYmFja2dyb3VuZDogcmdiYSgwLCAwLCAwLCAwLjA1KTtcXG59XFxuLnBhcmNvb3JkcyAuaGVhZGVyIHtcXG4gIGZvbnQtd2VpZ2h0OiBib2xkO1xcbn1cXG4ucGFyY29vcmRzIC5jZWxsIHtcXG4gIGZsb2F0OiBsZWZ0O1xcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcXG4gIHdoaXRlLXNwYWNlOiBub3dyYXA7XFxuICB3aWR0aDogMTAwcHg7XFxuICBoZWlnaHQ6IDE4cHg7XFxufVxcbi5wYXJjb29yZHMgLmNvbC0wIHtcXG4gIHdpZHRoOiAxODBweDtcXG59XFxuXCIsIFwiXCIsIHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIi9hcHAvc3VwZXJzZXQtZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BzdXBlcnNldC11aS9sZWdhY3ktcGx1Z2luLWNoYXJ0LXBhcmFsbGVsLWNvb3JkaW5hdGVzL2VzbS92ZW5kb3IvcGFyY29vcmRzL2QzLnBhcmNvb3Jkcy5jc3NcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIkFBQUEsbUJBQW1CO0FBQ25COztFQUVFLGdCQUFnQjtFQUNoQixtQkFBbUI7Q0FDcEI7QUFDRDtFQUNFLHFCQUFxQjtDQUN0Qjs7QUFFRDtFQUNFLFdBQVc7RUFDWCxnQkFBZ0I7RUFDaEIsYUFBYTtDQUNkOztBQUVEO0VBQ0Usa0JBQWtCO0NBQ25CO0FBQ0Q7RUFDRSwrQkFBK0I7Q0FDaEM7QUFDRDtFQUNFLHlCQUF5QjtDQUMxQjtBQUNEO0VBQ0UsZ0NBQWdDO0VBQ2hDLDJCQUEyQjtDQUM1QjtBQUNEOztFQUVFLFdBQVc7RUFDWCxhQUFhO0VBQ2IsNEJBQTRCO0NBQzdCO0FBQ0Q7RUFDRSxXQUFXO0VBQ1gsOEJBQThCO0VBQzlCLGlDQUFpQztFQUNqQyw0QkFBNEI7Q0FDN0I7QUFDRDtFQUNFLGNBQWM7Q0FDZjtBQUNEO0VBQ0UsNEJBQTRCO0VBQzVCLDBCQUEwQjtFQUMxQix5QkFBeUI7RUFDekIsdUJBQXVCO0VBQ3ZCLHNCQUFzQjtFQUN0QixrQkFBa0I7RUFDbEIsd0JBQXdCO0NBQ3pCOztBQUVELHVCQUF1QjtBQUN2Qjs7RUFFRSxZQUFZO0VBQ1osZ0JBQWdCO0VBQ2hCLGtCQUFrQjtFQUNsQixhQUFhO0VBQ2IsWUFBWTtDQUNiO0FBQ0Q7RUFDRSxnQ0FBZ0M7Q0FDakM7QUFDRDtFQUNFLGtCQUFrQjtDQUNuQjtBQUNEO0VBQ0UsWUFBWTtFQUNaLGlCQUFpQjtFQUNqQixvQkFBb0I7RUFDcEIsYUFBYTtFQUNiLGFBQWE7Q0FDZDtBQUNEO0VBQ0UsYUFBYTtDQUNkXCIsXCJmaWxlXCI6XCJkMy5wYXJjb29yZHMuY3NzXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIi8qIFtMSUNFTlNFIFRCRF0gKi9cXG4ucGFyY29vcmRzIHN2ZyxcXG4ucGFyY29vcmRzIGNhbnZhcyB7XFxuICBmb250LXNpemU6IDEycHg7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxufVxcbi5wYXJjb29yZHMgPiBjYW52YXMge1xcbiAgcG9pbnRlci1ldmVudHM6IG5vbmU7XFxufVxcblxcbi5wYXJjb29yZHMgdGV4dC5sYWJlbCB7XFxuICBmb250OiAxMDAlO1xcbiAgZm9udC1zaXplOiAxMnB4O1xcbiAgY3Vyc29yOiBkcmFnO1xcbn1cXG5cXG4ucGFyY29vcmRzIHJlY3QuYmFja2dyb3VuZCB7XFxuICBmaWxsOiB0cmFuc3BhcmVudDtcXG59XFxuLnBhcmNvb3JkcyByZWN0LmJhY2tncm91bmQ6aG92ZXIge1xcbiAgZmlsbDogcmdiYSgxMjAsIDEyMCwgMTIwLCAwLjIpO1xcbn1cXG4ucGFyY29vcmRzIC5yZXNpemUgcmVjdCB7XFxuICBmaWxsOiByZ2JhKDAsIDAsIDAsIDAuMSk7XFxufVxcbi5wYXJjb29yZHMgcmVjdC5leHRlbnQge1xcbiAgZmlsbDogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjI1KTtcXG4gIHN0cm9rZTogcmdiYSgwLCAwLCAwLCAwLjYpO1xcbn1cXG4ucGFyY29vcmRzIC5heGlzIGxpbmUsXFxuLnBhcmNvb3JkcyAuYXhpcyBwYXRoIHtcXG4gIGZpbGw6IG5vbmU7XFxuICBzdHJva2U6ICMyMjI7XFxuICBzaGFwZS1yZW5kZXJpbmc6IGNyaXNwRWRnZXM7XFxufVxcbi5wYXJjb29yZHMgY2FudmFzIHtcXG4gIG9wYWNpdHk6IDE7XFxuICAtbW96LXRyYW5zaXRpb246IG9wYWNpdHkgMC4zcztcXG4gIC13ZWJraXQtdHJhbnNpdGlvbjogb3BhY2l0eSAwLjNzO1xcbiAgLW8tdHJhbnNpdGlvbjogb3BhY2l0eSAwLjNzO1xcbn1cXG4ucGFyY29vcmRzIGNhbnZhcy5mYWRlZCB7XFxuICBvcGFjaXR5OiAwLjI1O1xcbn1cXG4ucGFyY29vcmRzIHtcXG4gIC13ZWJraXQtdG91Y2gtY2FsbG91dDogbm9uZTtcXG4gIC13ZWJraXQtdXNlci1zZWxlY3Q6IG5vbmU7XFxuICAta2h0bWwtdXNlci1zZWxlY3Q6IG5vbmU7XFxuICAtbW96LXVzZXItc2VsZWN0OiBub25lO1xcbiAgLW1zLXVzZXItc2VsZWN0OiBub25lO1xcbiAgdXNlci1zZWxlY3Q6IG5vbmU7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZTtcXG59XFxuXFxuLyogZGF0YSB0YWJsZSBzdHlsZXMgKi9cXG4ucGFyY29vcmRzIC5yb3csXFxuLnBhcmNvb3JkcyAuaGVhZGVyIHtcXG4gIGNsZWFyOiBsZWZ0O1xcbiAgZm9udC1zaXplOiAxMnB4O1xcbiAgbGluZS1oZWlnaHQ6IDE4cHg7XFxuICBoZWlnaHQ6IDE4cHg7XFxuICBtYXJnaW46IDBweDtcXG59XFxuLnBhcmNvb3JkcyAucm93Om50aC1jaGlsZChvZGQpIHtcXG4gIGJhY2tncm91bmQ6IHJnYmEoMCwgMCwgMCwgMC4wNSk7XFxufVxcbi5wYXJjb29yZHMgLmhlYWRlciB7XFxuICBmb250LXdlaWdodDogYm9sZDtcXG59XFxuLnBhcmNvb3JkcyAuY2VsbCB7XFxuICBmbG9hdDogbGVmdDtcXG4gIG92ZXJmbG93OiBoaWRkZW47XFxuICB3aGl0ZS1zcGFjZTogbm93cmFwO1xcbiAgd2lkdGg6IDEwMHB4O1xcbiAgaGVpZ2h0OiAxOHB4O1xcbn1cXG4ucGFyY29vcmRzIC5jb2wtMCB7XFxuICB3aWR0aDogMTgwcHg7XFxufVxcblwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuXG4vLyBleHBvcnRzXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/css-loader/index.js?!./node_modules/@superset-ui/legacy-plugin-chart-parallel-coordinates/esm/vendor/parcoords/d3.parcoords.css\n");

/***/ })

}]);